<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Extractor de Frases ‚Äî Eines ling√º√≠stiques</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --border: rgba(255,255,255,.12);
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --accent: #7c3aed;
      --accent2:#22c55e;
      --warn: #fb7185;
      --ring: 0 0 0 3px rgba(124,58,237,.22);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* TEMA CLAR */
    body.light-theme {
      --bg: #f8fafc;
      --panel: rgba(255,255,255,.95);
      --panel2: rgba(255,255,255,.98);
      --text: rgba(0,0,0,.92);
      --muted: rgba(0,0,0,.62);
      --border: rgba(0,0,0,.12);
      --shadow: 0 20px 60px rgba(0,0,0,.08);
      --ring: 0 0 0 3px rgba(124,58,237,.15);
    }

    * { box-sizing: border-box; font-family: var(--sans); }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(124,58,237,.28), transparent 60%),
        radial-gradient(1000px 600px at 90% 15%, rgba(34,197,94,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 95%, rgba(251,113,133,.14), transparent 55%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 22px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.light-theme {
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(124,58,237,.15), transparent 60%),
        radial-gradient(1000px 600px at 90% 15%, rgba(34,197,94,.1), transparent 55%),
        radial-gradient(900px 600px at 70% 95%, rgba(251,113,133,.08), transparent 55%),
        var(--bg);
    }

    .app{
      max-width: 1240px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 18px;
      align-items: start;
    }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
    }

    .topbar{
      max-width: 1240px;
      margin: 0 auto 18px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 16px;
      border: 1px solid var(--border);
      background: linear-gradient(to right, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    body.light-theme .topbar {
      background: linear-gradient(to right, rgba(255,255,255,.7), rgba(255,255,255,.4));
    }

    .brand{
      display:flex; align-items:center; gap: 12px;
    }
    .logo{
      width: 42px; height: 42px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(34,197,94,.75));
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .brand h1{
      margin:0;
      font-size: 16px;
      letter-spacing: .2px;
      line-height: 1.2;
    }
    .brand p{
      margin: 2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .quick{
      display:flex; align-items:center; gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    /* Cards */
    .card{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      transition: all 0.3s ease;
    }

    body.light-theme .card {
      box-shadow: 0 10px 40px rgba(0,0,0,.08);
    }

    .card-header{
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      transition: all 0.3s ease;
    }

    body.light-theme .card-header {
      background: rgba(255,255,255,.7);
    }

    .card-title{
      margin:0;
      font-size: 13px;
      letter-spacing: .3px;
      text-transform: uppercase;
      color: rgba(255,255,255,.78);
      transition: color 0.3s ease;
    }

    body.light-theme .card-title {
      color: rgba(0,0,0,.78);
    }

    .card-body{
      padding: 16px;
    }

    /* Form UI */
    .field{ margin-bottom: 14px; }
    label{
      display:block;
      margin-bottom: 6px;
      font-size: 12px;
      color: rgba(255,255,255,.78);
      transition: color 0.3s ease;
    }

    body.light-theme label {
      color: rgba(0,0,0,.78);
    }

    .hint{
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
    }

    input[type="text"], input[type="number"], select, textarea{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(10,16,30,.55);
      color: var(--text);
      outline: none;
      transition: .15s;
    }

    body.light-theme input[type="text"],
    body.light-theme input[type="number"],
    body.light-theme select,
    body.light-theme textarea {
      background: rgba(255,255,255,.9);
      color: rgba(0,0,0,.92);
      border-color: rgba(0,0,0,.15);
    }

    textarea{
      min-height: 190px;
      resize: vertical;
      line-height: 1.5;
    }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(124,58,237,.55);
      box-shadow: var(--ring);
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 520px){ .grid2{ grid-template-columns: 1fr; } }

    .sep{
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    /* Buttons */
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      transition: .15s;
      font-weight: 600;
      font-size: 13px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      user-select:none;
    }

    body.light-theme .btn {
      background: rgba(0,0,0,.06);
      color: rgba(0,0,0,.92);
      border-color: rgba(0,0,0,.12);
    }

    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    
    body.light-theme .btn:hover { 
      background: rgba(0,0,0,.10); 
    }

    .btn:active{ transform: translateY(0); }
    .btn:focus-visible{ outline: none; box-shadow: var(--ring); }

    .btn-primary{
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(124,58,237,.55));
      border-color: rgba(124,58,237,.45);
    }

    body.light-theme .btn-primary {
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(124,58,237,.75));
      border-color: rgba(124,58,237,.55);
      color: white;
    }

    .btn-primary:hover{ background: linear-gradient(135deg, rgba(124,58,237,1), rgba(124,58,237,.65)); }
    .btn-ghost{
      background: transparent;
    }
    .btn-danger{
      background: linear-gradient(135deg, rgba(251,113,133,.95), rgba(251,113,133,.55));
      border-color: rgba(251,113,133,.45);
    }

    .btn[disabled]{
      opacity:.55;
      cursor:not-allowed;
      transform:none !important;
    }

    .pillrow{
      display:flex; gap: 10px; flex-wrap: wrap;
    }

    /* Dropzone */
    .dropzone{
      border: 1px dashed rgba(255,255,255,.28);
      background: rgba(255,255,255,.04);
      border-radius: 18px;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      cursor: pointer;
      transition:.15s;
    }

    body.light-theme .dropzone {
      background: rgba(255,255,255,.8);
      border-color: rgba(0,0,0,.18);
    }

    .dropzone:hover{ background: rgba(255,255,255,.06); }
    
    body.light-theme .dropzone:hover {
      background: rgba(255,255,255,.9);
    }

    .dropzone.dragover{
      border-color: rgba(34,197,94,.7);
      background: rgba(34,197,94,.08);
      transform: scale(1.01);
    }

    body.light-theme .dropzone.dragover {
      background: rgba(34,197,94,.12);
    }

    .dz-top{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .dz-title{
      display:flex; flex-direction: column; gap: 2px;
    }
    .dz-title strong{ font-size: 13px; }
    .dz-title span{ font-size: 12px; color: var(--muted); }
    .fileinfo{
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.85);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    body.light-theme .fileinfo {
      background: rgba(0,0,0,.05);
      color: rgba(0,0,0,.85);
    }

    /* Check/radio */
    .checks{ display:flex; flex-direction: column; gap: 10px; }
    .check{
      display:flex; gap: 10px; align-items: flex-start;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(255,255,255,.04);
    }

    body.light-theme .check {
      background: rgba(0,0,0,.04);
    }

    .check input{ margin-top: 2px; }
    .check b{ font-size: 13px; display:block; }
    .check small{ color: var(--muted); font-size: 12px; }

    /* Results */
    .results-toolbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .count-badge{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.86);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
    }

    body.light-theme .count-badge {
      background: rgba(0,0,0,.06);
      color: rgba(0,0,0,.86);
      border-color: rgba(0,0,0,.12);
    }

    .results-list{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
      max-height: 560px;
      overflow: auto;
      padding-right: 4px;
    }

    .result{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      border-radius: 18px;
      padding: 12px;
      transition: all 0.3s ease;
    }

    body.light-theme .result {
      background: rgba(255,255,255,.9);
    }

    .result-head{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 8px;
      color: rgba(255,255,255,.72);
      font-size: 12px;
      margin-bottom: 8px;
    }

    body.light-theme .result-head {
      color: rgba(0,0,0,.72);
    }

    .result-body{
      font-size: 14px;
      line-height: 1.6;
      color: rgba(255,255,255,.92);
    }

    body.light-theme .result-body {
      color: rgba(0,0,0,.92);
    }

    .result-meta{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
      font-style: italic;
    }

    .empty{
      padding: 22px 14px;
      border: 1px dashed rgba(255,255,255,.24);
      border-radius: 18px;
      color: var(--muted);
      text-align:center;
    }

    body.light-theme .empty {
      border-color: rgba(0,0,0,.24);
    }

    /* Highlights - CORREGIT: Nom√©s una classe sense accent */
    .highlight{ background: rgba(255,249,196,.92); color: #111827; padding: 1px 4px; border-radius: 6px; font-weight: 700; }
    
    body.light-theme .highlight {
      background: rgba(255,235,59,.92);
    }

    .esdruixola-highlight{ background:#ff9800; color:#111827; padding:1px 4px; border-radius:6px; font-weight:900; }
    .temps-highlight{ background:#22c55e; color:#052e12; padding:1px 4px; border-radius:6px; font-weight:900; }
    .verb-highlight{ background:#a855f7; color:#1f0930; padding:1px 4px; border-radius:6px; font-weight:900; }

    .word-count-info{
      display:inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.78);
      font-size: 12px;
      font-family: var(--mono);
    }

    body.light-theme .word-count-info {
      background: rgba(0,0,0,.05);
      color: rgba(0,0,0,.78);
    }

    /* Sticky action footer */
    .sticky-actions{
      position: sticky;
      bottom: 14px;
      padding: 12px;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-top: 14px;
    }

    body.light-theme .sticky-actions {
      background: rgba(255,255,255,.85);
    }

    .sticky-actions .btn{ flex: 1; justify-content: center; min-width: 140px; }

    /* Loading + toast */
    .loading{
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      font-size: 12px;
      align-items:center;
      gap: 10px;
    }

    body.light-theme .loading {
      background: rgba(0,0,0,.05);
      color: rgba(0,0,0,.85);
    }

    .dot{
      width: 8px; height: 8px;
      border-radius: 999px;
      background: var(--accent2);
      box-shadow: 0 0 0 6px rgba(34,197,94,.15);
      animation: pulse 1.2s infinite ease-in-out;
    }
    @keyframes pulse{
      0%,100%{ transform: scale(1); opacity:.9 }
      50%{ transform: scale(1.2); opacity:.55 }
    }

    .toast{
      position: fixed;
      top: 16px;
      right: 16px;
      max-width: min(520px, 92vw);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      display:none;
      z-index: 999;
      font-size: 13px;
    }

    body.light-theme .toast {
      background: rgba(255,255,255,.9);
    }

    .toast.ok{ border-color: rgba(34,197,94,.35); }
    .toast.err{ border-color: rgba(251,113,133,.45); }
    .toast b{ display:block; margin-bottom:2px; }
    .toast span{ color: var(--muted); font-size: 12px; }

    .kbd{
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.82);
    }

    body.light-theme .kbd {
      background: rgba(0,0,0,.06);
      color: rgba(0,0,0,.82);
      border-color: rgba(0,0,0,.12);
    }

    /* Estils per a les paraules adjacents */
    .adjacent-words-panel {
      margin-top: 20px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.04);
      border-radius: 18px;
      padding: 16px;
      display: none;
    }

    body.light-theme .adjacent-words-panel {
      background: rgba(255,255,255,.9);
    }

    .adjacent-words-title {
      font-size: 14px;
      color: rgba(255,255,255,.85);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    body.light-theme .adjacent-words-title {
      color: rgba(0,0,0,.85);
    }

    .adjacent-words-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (max-width: 768px) {
      .adjacent-words-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .adjacent-section {
      background: rgba(10,16,30,.6);
      border-radius: 14px;
      padding: 14px;
      border: 1px solid rgba(255,255,255,.1);
    }

    body.light-theme .adjacent-section {
      background: rgba(255,255,255,.9);
      border: 1px solid rgba(0,0,0,.1);
    }
    
    .adjacent-section-title {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .adjacent-section-count {
      background: rgba(124,58,237,.2);
      color: rgba(255,255,255,.9);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-family: var(--mono);
    }

    body.light-theme .adjacent-section-count {
      color: rgba(0,0,0,.9);
    }
    
    .adjacent-words-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    
    .adjacent-word-item {
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 10px;
      padding: 8px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      transition: all 0.2s;
    }

    body.light-theme .adjacent-word-item {
      background: rgba(0,0,0,.05);
      border: 1px solid rgba(0,0,0,.1);
    }
    
    .adjacent-word-item:hover {
      background: rgba(255,255,255,.12);
      transform: translateY(-1px);
    }

    body.light-theme .adjacent-word-item:hover {
      background: rgba(0,0,0,.08);
    }
    
    .adjacent-word-text {
      flex: 1;
      color: rgba(255,255,255,.85);
      word-break: break-word;
    }

    body.light-theme .adjacent-word-text {
      color: rgba(0,0,0,.85);
    }
    
    .adjacent-word-count {
      background: rgba(34,197,94,.3);
      color: rgba(255,255,255,.95);
      min-width: 24px;
      height: 24px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      font-family: var(--mono);
      margin-left: 10px;
    }

    body.light-theme .adjacent-word-count {
      background: rgba(34,197,94,.4);
      color: rgba(0,0,0,.95);
    }
    
    .adjacent-words-empty {
      color: var(--muted);
      font-size: 12px;
      font-style: italic;
      text-align: center;
      padding: 10px;
    }
    
    /* Control per a la cerca de paraules adjacents */
    .adjacent-words-controls {
      margin-top: 10px;
      display: none;
    }
    
    .adjacent-words-controls.active {
      display: block;
    }
    
    .adjacent-control-label {
      font-size: 11px;
      color: rgba(255,255,255,.7);
      margin-bottom: 4px;
      display: block;
    }

    body.light-theme .adjacent-control-label {
      color: rgba(0,0,0,.7);
    }
    
    .adjacent-controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .adjacent-control-input {
      width: 80px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(10,16,30,.6);
      color: var(--text);
      font-size: 12px;
    }

    body.light-theme .adjacent-control-input {
      background: rgba(255,255,255,.9);
      color: rgba(0,0,0,.92);
    }
  </style>
</head>

<body>
  <div id="toast" class="toast"></div>

  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Extractor de Frases</h1>
        <p>Filtres ling√º√≠stics (esdr√∫ixoles, temps, verbs) + context i longitud</p>
      </div>
    </div>
    <div class="quick">
      <span class="kbd">PDF/TXT</span>
      <span class="kbd">Ctrl/Cmd + C</span>
      <span class="kbd">Resultats</span>
      <button id="themeToggle" class="btn btn-ghost" style="padding: 4px 8px; font-size: 12px;">
        üåô Tema
      </button>
    </div>
  </div>

  <div class="app">
    <!-- SIDEBAR: Entrada + Filtres -->
    <aside class="card">
      <div class="card-header">
        <h2 class="card-title">Entrada & Filtres</h2>
        <div id="loadingIndicator" class="loading" aria-live="polite">
          <div class="dot" aria-hidden="true"></div>
          <div>Processant‚Ä¶</div>
        </div>
      </div>

      <div class="card-body">
        <!-- Dropzone -->
        <div class="field">
          <div id="dropArea" class="dropzone" tabindex="0" role="button" aria-label="Arrossega un fitxer o fes clic per seleccionar-ne un">
            <div class="dz-top">
              <div class="dz-title">
                <strong>Carrega un fitxer</strong>
                <span>Arrossega aqu√≠ o fes clic (PDF o TXT)</span>
              </div>
              <div class="pillrow">
                <button type="button" class="btn btn-ghost" id="selectFileBtn">üìé Seleccionar</button>
                <button type="button" class="btn btn-ghost" id="clearFileBtn">üßπ Netejar</button>
              </div>
            </div>
            <input type="file" id="fileInput" style="display:none" accept=".pdf,.txt" />
            <div id="fileInfo" class="fileinfo"></div>
          </div>
        </div>

        <!-- Text -->
        <div class="field">
          <label for="inputText">Text a analitzar</label>
          <textarea id="inputText" placeholder="Enganxa aqu√≠ el text o carrega un PDF/TXT‚Ä¶">Hi ha vegades que no entenc res del que passa. A vegades que jo recordi, aix√≤ no havia passat mai. Hi ha moltes vegades que penso en aix√≤. De vegades en qu√® m'avorreixo, llegeix. Vegades hi ha coses estranyes. Aquestes vegades que parlem s√≥n importants.</textarea>
          <div class="pillrow" style="margin-top:10px;">
            <button type="button" class="btn" id="sampleTextBtn">‚ú® Exemple</button>
            <button type="button" class="btn" id="clearTextBtn">üóëÔ∏è Buida</button>
          </div>
        </div>

        <div class="sep"></div>

        <!-- Cerca -->
        <div class="field">
          <label for="searchType">Tipus de cerca</label>
          <select id="searchType">
            <option value="text">Cadena de text</option>
            <option value="esdruixoles">Paraules esdr√∫ixoles</option>
            <option value="temps">Expressions de temps</option>
            <option value="verb">Formes verbals</option>
          </select>
        </div>

        <div class="grid2">
          <div class="field" id="textSearchGroup">
            <label for="searchText">Text a buscar</label>
            <input type="text" id="searchText" placeholder="Ex: m√∫sica, Barcelona, etc."/>
            <div class="hint">Deixa buit per extreure totes les frases.</div>
          </div>

          <div class="field" id="lletresEspecifiquesGroup" style="display:none;">
            <label for="lletresEspecifiques">Seq√º√®ncia dins esdr√∫ixoles</label>
            <input type="text" id="lletresEspecifiques" placeholder="Ex: pr, l¬∑l, ment"/>
            <div class="hint">Pots posar-ne m√©s d'una: <span class="kbd">pr, l¬∑l</span></div>
          </div>
        </div>

        <div class="field">
          <label for="matchPattern">Patr√≥</label>
          <select id="matchPattern">
            <option value="anywhere">En qualsevol posici√≥</option>
            <option value="exact">Coincid√®ncia exacta</option>
            <option value="starts">Comen√ßada per</option>
            <option value="ends">Acabada en</option>
            <option value="notends">No acabada en</option>
            <option value="notcontains">Que no contingui</option>
          </select>

          <div class="grid2" style="margin-top:10px;">
            <div class="field" id="notEndsWithInput" style="display:none; margin:0;">
              <label for="notEndsWithText">No acaba amb</label>
              <input type="text" id="notEndsWithText" placeholder="Ex: ment, ci√≥‚Ä¶"/>
            </div>

            <div class="field" id="notContainsInput" style="display:none; margin:0;">
              <label for="notContainsText">No cont√©</label>
              <input type="text" id="notContainsText" placeholder="Ex: l¬∑l, gua‚Ä¶"/>
            </div>
          </div>
        </div>

        <div class="sep"></div>

        <!-- NOVA OPCI√ì: Paraules adjacents -->
        <div class="field">
          <label>Paraules adjacents (NOVETAT)</label>
          <div class="checks">
            <div class="check">
              <input type="checkbox" id="enableAdjacentWords"/>
              <div>
                <b>Mostrar an√†lisi de freq√º√®ncies</b>
                <small>Mostra estad√≠stiques de les paraules que precedeixen i segueixen.</small>
              </div>
            </div>
          </div>
          
          <div id="adjacentWordsConfig" class="adjacent-words-controls">
            <div class="adjacent-control-label">Nombre de paraules a analitzar (es compten com a grups):</div>
            <div class="adjacent-controls-row">
              <div style="flex: 1;">
                <div class="adjacent-control-label">Que precedeixen:</div>
                <input type="number" id="adjacentPrecedingCount" class="adjacent-control-input" value="1" min="1" max="5">
              </div>
              <div style="flex: 1;">
                <div class="adjacent-control-label">Que segueixen:</div>
                <input type="number" id="adjacentFollowingCount" class="adjacent-control-input" value="1" min="1" max="5">
              </div>
            </div>
            <div class="hint" style="margin-top: 8px;">
              Ex: Si poses 2, es comptaran parells de paraules adjacents (ex: 'hi ha', 'a vegades')
            </div>
          </div>
        </div>

        <div class="sep"></div>

        <div class="field">
          <label>Opcions</label>
          <div class="checks">
            <div class="check">
              <input type="checkbox" id="category1" checked/>
              <div>
                <b>Destacar coincid√®ncies</b>
                <small>Marca en color les paraules trobades.</small>
              </div>
            </div>
            <div class="check">
              <input type="checkbox" id="category2"/>
              <div>
                <b>Incloure marques sil¬∑l√†biques</b>
                <small>Mostra la separaci√≥ en s√≠l¬∑labes (nom√©s en esdr√∫ixoles).</small>
              </div>
            </div>
          </div>
        </div>

        <div class="field">
          <label>Longitud (paraules per frase)</label>
          <div class="grid2">
            <div class="field" style="margin:0;">
              <label for="minWords">M√≠nim</label>
              <input type="number" id="minWords" value="1" min="1" max="50"/>
            </div>
            <div class="field" style="margin:0;">
              <label for="maxWords">M√†xim</label>
              <input type="number" id="maxWords" value="50" min="1" max="100"/>
            </div>
          </div>
        </div>

        <div class="sticky-actions">
          <button type="button" class="btn btn-primary" id="extractButton">üîé Extreure</button>
          <button type="button" class="btn" id="copyResultsBtn">üìã Copiar</button>
          <button type="button" class="btn btn-danger" id="resetBtn">‚Ü©Ô∏è Reiniciar</button>
        </div>
      </div>
    </aside>

    <!-- MAIN: Resultats -->
    <main class="card">
      <div class="card-header">
        <h2 class="card-title">Resultats</h2>
        <div class="results-toolbar">
          <div class="count-badge">Frases trobades: <span id="resultsCount">0</span></div>
        </div>
      </div>
      <div class="card-body">
        <div id="resultsList" class="results-list">
          <div class="empty">Quan executis <b>Extreure</b>, aqu√≠ veur√†s les frases filtrades.</div>
        </div>
        
        <!-- NOU: Panell de paraules adjacents -->
        <div id="adjacentWordsPanel" class="adjacent-words-panel">
          <div class="adjacent-words-title">An√†lisi de freq√º√®ncies de paraules adjacents</div>
          <div class="adjacent-words-grid">
            <div class="adjacent-section">
              <div class="adjacent-section-title">
                <span>Paraules que precedeixen "<span id="precedingSearchWord"></span>"</span>
                <span id="precedingWordsCount" class="adjacent-section-count">0</span>
              </div>
              <div id="precedingWordsList" class="adjacent-words-list">
                <div class="adjacent-words-empty">No hi ha dades</div>
              </div>
            </div>
            <div class="adjacent-section">
              <div class="adjacent-section-title">
                <span>Paraules que segueixen "<span id="followingSearchWord"></span>"</span>
                <span id="followingWordsCount" class="adjacent-section-count">0</span>
              </div>
              <div id="followingWordsList" class="adjacent-words-list">
                <div class="adjacent-words-empty">No hi ha dades</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";

    document.addEventListener("DOMContentLoaded", () => {
      // Bot√≥ de canvi de tema
      const themeToggle = document.getElementById('themeToggle');

      // Comprovar tema guardat o prefer√®ncia del sistema
      const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
      const savedTheme = localStorage.getItem('theme') || (prefersLight ? 'light' : 'dark');

      // Aplicar tema guardat
      if (savedTheme === 'light') {
        document.body.classList.add('light-theme');
        themeToggle.innerHTML = '‚òÄÔ∏è Tema';
      } else {
        themeToggle.innerHTML = 'üåô Tema';
      }

      // Alternar tema
      themeToggle.addEventListener('click', () => {
        const isLight = document.body.classList.toggle('light-theme');
        
        if (isLight) {
          themeToggle.innerHTML = '‚òÄÔ∏è Tema';
          localStorage.setItem('theme', 'light');
        } else {
          themeToggle.innerHTML = 'üåô Tema';
          localStorage.setItem('theme', 'dark');
        }
      });

      // DOM
      const el = {
        searchType: document.getElementById("searchType"),
        extractButton: document.getElementById("extractButton"),
        resultsList: document.getElementById("resultsList"),
        resultsCount: document.getElementById("resultsCount"),
        inputText: document.getElementById("inputText"),
        matchPattern: document.getElementById("matchPattern"),
        loadingIndicator: document.getElementById("loadingIndicator"),

        fileInput: document.getElementById("fileInput"),
        selectFileBtn: document.getElementById("selectFileBtn"),
        dropArea: document.getElementById("dropArea"),
        fileInfo: document.getElementById("fileInfo"),
        clearFileBtn: document.getElementById("clearFileBtn"),

        sampleTextBtn: document.getElementById("sampleTextBtn"),
        clearTextBtn: document.getElementById("clearTextBtn"),
        copyResultsBtn: document.getElementById("copyResultsBtn"),
        resetBtn: document.getElementById("resetBtn"),

        textSearchGroup: document.getElementById("textSearchGroup"),
        lletresEspecifiquesGroup: document.getElementById("lletresEspecifiquesGroup"),

        notEndsWithInput: document.getElementById("notEndsWithInput"),
        notContainsInput: document.getElementById("notContainsInput"),

        toast: document.getElementById("toast"),
        
        // NOUS ELEMENTS: Paraules adjacents
        enableAdjacentWords: document.getElementById("enableAdjacentWords"),
        adjacentWordsConfig: document.getElementById("adjacentWordsConfig"),
        adjacentPrecedingCount: document.getElementById("adjacentPrecedingCount"),
        adjacentFollowingCount: document.getElementById("adjacentFollowingCount"),
        adjacentWordsPanel: document.getElementById("adjacentWordsPanel"),
        precedingWordsList: document.getElementById("precedingWordsList"),
        followingWordsList: document.getElementById("followingWordsList"),
        precedingWordsCount: document.getElementById("precedingWordsCount"),
        followingWordsCount: document.getElementById("followingWordsCount"),
        precedingSearchWord: document.getElementById("precedingSearchWord"),
        followingSearchWord: document.getElementById("followingSearchWord")
      };

      const controlsToDisable = [
        el.extractButton, el.copyResultsBtn, el.resetBtn,
        el.selectFileBtn, el.clearFileBtn, el.sampleTextBtn, el.clearTextBtn
      ];

      function setBusy(isBusy, message = "Processant‚Ä¶") {
        controlsToDisable.forEach(b => b.disabled = isBusy);
        el.loadingIndicator.style.display = isBusy ? "inline-flex" : "none";
        if (isBusy) el.loadingIndicator.querySelector("div:last-child").textContent = message;
      }

      function toast(kind, title, detail = "", ms = 3200){
        el.toast.className = "toast " + (kind === "err" ? "err" : "ok");
        el.toast.innerHTML = `<b>${title}</b><span>${detail}</span>`;
        el.toast.style.display = "block";
        setTimeout(() => (el.toast.style.display = "none"), ms);
      }

      // UI: show/hide
      function updateSearchTypeUI(){
        const v = el.searchType.value;
        if (v === "esdruixoles") {
          el.textSearchGroup.style.display = "none";
          el.lletresEspecifiquesGroup.style.display = "block";
        } else {
          el.textSearchGroup.style.display = "block";
          el.lletresEspecifiquesGroup.style.display = "none";
        }
      }

      function updateNegationUI(){
        el.notEndsWithInput.style.display = "none";
        el.notContainsInput.style.display = "none";
        if (el.matchPattern.value === "notends") el.notEndsWithInput.style.display = "block";
        if (el.matchPattern.value === "notcontains") el.notContainsInput.style.display = "block";
      }

      // NOVA FUNCI√ì: Mostrar/amagar configuraci√≥ de paraules adjacents
      function updateAdjacentWordsUI() {
        if (el.enableAdjacentWords.checked) {
          el.adjacentWordsConfig.classList.add("active");
        } else {
          el.adjacentWordsConfig.classList.remove("active");
        }
      }

      el.searchType.addEventListener("change", () => { updateSearchTypeUI(); updateNegationUI(); });
      el.matchPattern.addEventListener("change", updateNegationUI);
      el.enableAdjacentWords.addEventListener("change", updateAdjacentWordsUI);

      // Dropzone clicks (avoid button conflicts)
      el.dropArea.addEventListener("click", (e) => {
        if (e.target.closest("button")) return;
        el.fileInput.click();
      });
      el.dropArea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          el.fileInput.click();
        }
      });
      el.selectFileBtn.addEventListener("click", (e) => { e.stopPropagation(); el.fileInput.click(); });
      el.clearFileBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        el.fileInput.value = "";
        el.fileInfo.style.display = "none";
        el.fileInfo.textContent = "";
        toast("ok", "Fitxer eliminat", "S'ha netejat la selecci√≥.");
      });

      // Drag and drop
      ["dragenter","dragover","dragleave","drop"].forEach(evt => {
        el.dropArea.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); });
      });
      ["dragenter","dragover"].forEach(evt => {
        el.dropArea.addEventListener(evt, () => el.dropArea.classList.add("dragover"));
      });
      ["dragleave","drop"].forEach(evt => {
        el.dropArea.addEventListener(evt, () => el.dropArea.classList.remove("dragover"));
      });
      el.dropArea.addEventListener("drop", (e) => {
        const files = e.dataTransfer.files;
        if (files && files.length) {
          el.fileInput.files = files;
          handleFileSelect();
        }
      });

      el.fileInput.addEventListener("change", handleFileSelect);

      async function handleFileSelect(){
        if (!el.fileInput.files.length) return;
        const file = el.fileInput.files[0];
        const ext = file.name.split(".").pop().toLowerCase();
        if (ext !== "pdf" && ext !== "txt"){
          toast("err", "Fitxer no v√†lid", "Nom√©s PDF o TXT.");
          return;
        }

        el.fileInfo.style.display = "block";
        el.fileInfo.textContent = `Fitxer: ${file.name} (${formatFileSize(file.size)})`;

        setBusy(true, "Carregant fitxer‚Ä¶");
        try{
          let textContent = "";
          if (ext === "pdf") textContent = await extractTextFromPDF(file);
          else textContent = await extractTextFromTXT(file);

          el.inputText.value = textContent.trim();
          toast("ok", "Fitxer carregat", `S'ha importat el contingut (${ext.toUpperCase()}).`);
        }catch(err){
          console.error(err);
          toast("err", "Error en carregar", err.message || "No s'ha pogut llegir el fitxer.");
        }finally{
          setBusy(false);
        }
      }

      async function extractTextFromPDF(file){
        const buffer = await file.arrayBuffer();
        const typedArray = new Uint8Array(buffer);
        const pdf = await pdfjsLib.getDocument(typedArray).promise;

        let allText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(" ");
          allText += pageText + " ";
        }
        return allText;
      }

      async function extractTextFromTXT(file){
        return await file.text();
      }

      function formatFileSize(bytes){
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes","KB","MB","GB"];
        const i = Math.floor(Math.log(bytes)/Math.log(k));
        return parseFloat((bytes/Math.pow(k,i)).toFixed(2)) + " " + sizes[i];
      }

      // Text helpers
      function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

      // Funci√≥ millorada per escapar regex que inclou car√†cters catalans
      function escapeRegExpForSearch(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function splitIntoSentences(text){
        const protectedText = text.replace(/l[¬∑.‚Ä¢]l/gi, "L_GEMINADA");
        const sentences = protectedText.split(/(?<=[.!?])\s+/);
        return sentences.map(s => s.replace(/L_GEMINADA/gi, "l¬∑l")).map(s => s.trim()).filter(Boolean);
      }

      // S√çL¬∑LABES (tal com el teu)
      function processarParaulaSilabes(paraula) {
        let paraulaProcessada = paraula;
        let canvi;

        paraulaProcessada = paraulaProcessada.replace(/arg√º(eix|i|√≠)/gi, 'arg√º-$1');
        paraulaProcessada = paraulaProcessada.replace(/(M√†ri|S√≠ri)us($)/gi, '$1-us$2');
        paraulaProcessada = paraulaProcessada.replace(/l¬∑l/gi, 'l-l');

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])([bcdfghjklmnpqrstvwxyz√ß])([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, c, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + c + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([a-z√ß√†√®√©√≠√Ø√≤√≥√∫√º])(ll|ny|kh|bl|br|cl|cr|dr|fl|fr|gl|gr|pl|pr|tr)([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, cons, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + cons + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])([bcdfghjklmnpqrstvwxyz√ß]{2,})([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, cons, v2) => {
              if (!match.includes('-')) {
                canvi = true;
                const pre = cons.substring(0, cons.length - 1);
                const last = cons.substring(cons.length - 1);
                return v1 + pre + '-' + last + v2;
              }
              return match;
            }
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        paraulaProcessada = paraulaProcessada.replace(/([gq])u([aeiou√†√®√©√≠√≤√≥√∫√º])/gi, '$1*u*$2');

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([a√†e√©√®i√≠o√≤√≥u√∫])([iu])([aeiou])([iu])/gi,
            (match, v1, iu1, v2, iu2) => (!match.includes('-') ? (canvi = true, v1 + '-' + iu1 + '*' + v2 + iu2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√≤√≥√∫])([iu])([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, iu, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + iu + '*' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou])([√†√®√©√≠√≤√≥√∫√Ø√º])/gi,
            (match, v1, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([bcdfgjklmnpqrstvwxyz√ß])([iu])([aeo])/gi,
            (match, c, iu, v) => (!match.includes('-') ? (canvi = true, c + iu + '-' + v) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeo√†√®√©√≤√≥])([aeo√†√®√©√≤√≥])/gi,
            (match, v1, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou])um($|s$)/gi,
            (match, v, fin) => (!match.includes('-') ? (canvi = true, v + '-um' + fin) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        paraulaProcessada = paraulaProcessada.replace(/\*/gi, '');
        paraulaProcessada = paraulaProcessada.replace(/--+/g, '-');
        paraulaProcessada = paraulaProcessada.replace(/^-/, '');

        return paraulaProcessada;
      }

      // FUNCI√ì CORREGIDA: Determinar si una paraula √©s esdr√∫ixola
      function esEsdruixola(paraula) {
        // Neteja la paraula - tractar ap√≤strofs
        const paraulaNeta = paraula.replace(/^[lLdDsSnNtTmM]['']|[.,!?;:‚Äî()¬ª]$/gi, '').replace(/[.,!?;:‚Äî()¬ª]$/, '');
        
        // Si la paraula √©s massa curta, no pot ser esdr√∫ixola
        if (paraulaNeta.length < 3) return false;
        
        // Separa la paraula en s√≠l¬∑labes
        const paraulaSeparada = processarParaulaSilabes(paraulaNeta);
        const silabes = paraulaSeparada.split('-').filter(s => s.length > 0);
        
        // Necessita almenys 3 s√≠l¬∑labes per ser esdr√∫ixola
        if (silabes.length < 3) return false;
        
        // Buscar accent a les s√≠l¬∑labes (nom√©s accents reals, no di√®resis)
        for (let i = 0; i < silabes.length; i++) {
          if (/[√†√®√©√≠√≤√≥√∫]/.test(silabes[i])) {
            // Si l'accent est√† a la antepen√∫ltima o abans, √©s esdr√∫ixola
            const posicioDesDelFinal = silabes.length - 1 - i;
            return posicioDesDelFinal >= 2;
          }
        }
        
        return false;
      }

      // FUNCI√ì CORREGIDA: Obtenir totes les paraules esdr√∫ixoles d'una frase
      function obtenirEsdruixolesDeFrase(frase) {
        // Regex per trobar paraules (incloent les amb ap√≤strof)
        const paraules = frase.match(/\b(?:[lLdDsSnNtTmM][''])?[a-zA-Z√Ä-√ø√ß√á]+/g) || [];
        const esdruixoles = [];
        
        paraules.forEach(paraula => {
          if (esEsdruixola(paraula)) {
            esdruixoles.push(paraula);
          }
        });
        
        return esdruixoles;
      }

      // FUNCI√ì MILLORADA: Per destacar paraules esdr√∫ixoles sense incloure l'ap√≤strof - CORREGIT
      function highlightEsdruixoles(frase) {
        // Obtenir totes les esdr√∫ixoles
        const esdruixoles = obtenirEsdruixolesDeFrase(frase);
        let resultat = frase;
        
        // Ordenar de m√©s llarga a m√©s curta per evitar reempla√ßaments parcials
        esdruixoles.sort((a, b) => b.length - a.length);
        
        // Per a cada esdr√∫ixola, reempla√ßar-la amb highlight
        esdruixoles.forEach(paraula => {
          // Hem de trobar la forma exacta tal com apareix a la frase
          // Aix√≤ inclou ap√≤strofs i altres car√†cters
          const paraulesFrase = frase.match(/\b(?:[lLdDsSnNtTmM][''])?[a-zA-Z√Ä-√ø√ß√á]+\b/g) || [];
          
          // Buscar la paraula tal com apareix a la frase
          let paraulaFrase = paraula;
          for (let pf of paraulesFrase) {
            // Comprovar si aquesta paraula de la frase √©s l'esdr√∫ixola
            // Per√≤ neteja primer els ap√≤strofs
            const pfNeta = pf.replace(/^[lLdDsSnNtTmM]['']/, '');
            if (pfNeta === paraula.replace(/^[lLdDsSnNtTmM]['']/, '')) {
              paraulaFrase = pf;
              break;
            }
          }
          
          // Escapar car√†cters especials per a regex
          const paraulaEscapada = paraulaFrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          
          // Crear l'highlight nom√©s per la part de la paraula, no l'ap√≤strof
          // Separar l'ap√≤strof inicial de la paraula
          const match = paraulaFrase.match(/^([lLdDsSnNtTmM][''])?(.+)$/);
          if (match) {
            const apostrof = match[1] || '';
            const paraulaSenseApostrof = match[2];
            
            // Si hi ha ap√≤strof, mantenir-lo fora de l'highlight
            if (apostrof) {
              const regex = new RegExp(`(${escapeRegExp(apostrof)}${escapeRegExp(paraulaSenseApostrof)})`, 'g');
              resultat = resultat.replace(regex, 
                `${apostrof}<span class="esdruixola-highlight">${paraulaSenseApostrof}</span>`);
            } else {
              // Sense ap√≤strof, destacar la paraula sencera - CORREGIT: sense accent
              const regex = new RegExp(`\\b${escapeRegExp(paraulaFrase)}\\b`, 'g');
              resultat = resultat.replace(regex, 
                `<span class="esdruixola-highlight">${paraulaFrase}</span>`);
            }
          }
        });
        
        return resultat;
      }

      // FUNCI√ì NOVA: Destacar lletres espec√≠fiques dins les paraules esdr√∫ixoles amb ap√≤strof
      function highlightLletresEnEsdruixoles(frase, lletresEspecifiques, esdruixoles) {
        if (!lletresEspecifiques || !esdruixoles || esdruixoles.length === 0) {
          return frase;
        }
        
        let resultat = frase;
        
        // Per cada paraula esdr√∫ixola
        esdruixoles.forEach(paraula => {
          // Trobar la paraula com apareix a la frase (amb ap√≤strof si el t√©)
          const paraulesFrase = frase.match(/\b(?:[lLdDsSnNtTmM][''])?[a-zA-Z√Ä-√ø√ß√á]+\b/g) || [];
          let paraulaFrase = paraula;
          
          for (let pf of paraulesFrase) {
            const pfNeta = pf.replace(/^[lLdDsSnNtTmM]['']/, '');
            if (pfNeta === paraula.replace(/^[lLdDsSnNtTmM]['']/, '')) {
              paraulaFrase = pf;
              break;
            }
          }
          
          // Separar ap√≤strof si n'hi ha
          const match = paraulaFrase.match(/^([lLdDsSnNtTmM][''])?(.+)$/);
          if (!match) return;
          
          const apostrof = match[1] || '';
          const paraulaSenseApostrof = match[2];
          
          // Crear versi√≥ amb les lletres destacades
          let paraulaDestacada = paraulaSenseApostrof;
          
          // Destacar cada lletra espec√≠fica
          lletresEspecifiques.split('').forEach(lletra => {
            const regex = new RegExp(`(${escapeRegExp(lletra)})`, 'gi');
            paraulaDestacada = paraulaDestacada.replace(regex, 
              `<span style="background-color: #ff5722; color: white; font-weight: bold; padding: 1px 3px; border-radius: 2px;">$1</span>`);
          });
          
          // Reempla√ßar a la frase
          const paraulaCompleta = apostrof + paraulaSenseApostrof;
          const paraulaDestacadaCompleta = apostrof + paraulaDestacada;
          
          const regex = new RegExp(escapeRegExp(paraulaCompleta), 'g');
          resultat = resultat.replace(regex, paraulaDestacadaCompleta);
        });
        
        return resultat;
      }

      function findTimeExpressions(text) {
        const timePatterns = [
          /\bavui\b/gi, /\bdem√†\b/gi, /\bahir\b/gi, /\bsetmana\b/gi, /\bmes\b/gi, /\bany\b/gi,
          /\bdilluns\b/gi, /\bdimarts\b/gi, /\bdimecres\b/gi, /\bdijous\b/gi, /\bdivendres\b/gi,
          /\bdissabte\b/gi, /\bdiumenge\b/gi, /\bmat√≠\b/gi, /\btarda\b/gi, /\bnit\b/gi,
          /\bprimavera\b/gi, /\bestiu\b/gi, /\btardor\b/gi, /\bhivern\b/gi,
          /\bdia\b/gi, /\bhor[ae]\b/gi, /\bminut[os]?\b/gi, /\bsegon[os]?\b/gi
        ];
        const matches = [];
        timePatterns.forEach(p => { const m = text.match(p); if (m) matches.push(...m); });
        return [...new Set(matches)];
      }

      function highlightTimeExpressions(frase){
        let out = frase;
        findTimeExpressions(frase).forEach(expr=>{
          out = out.replace(new RegExp(`\\b${escapeRegExp(expr)}\\b`, "gi"), `<span class="temps-highlight">$&</span>`);
        });
        return out;
      }

      function findVerbForms(text){
        const verbPatterns = [
          /\bvaig\b/gi, /\bvas\b/gi, /\bva\b/gi, /\bvam\b/gi, /\bvau\b/gi, /\bvan\b/gi,
          /\bestic\b/gi, /\best√†s\b/gi, /\best√†\b/gi, /\bestem\b/gi, /\bestau\b/gi, /\bestan\b/gi,
          /\bhe\b/gi, /\bhas\b/gi, /\bha\b/gi, /\bhem\b/gi, /\bheu\b/gi, /\bhan\b/gi,
          /\bs√≥c\b/gi, /\bets\b/gi, /\b√©s\b/gi, /\bsom\b/gi, /\beu\b/gi, /\bs√≥n\b/gi,
          /\bera\b/gi, /\beres\b/gi, /\b√©rem\b/gi, /\b√©reu\b/gi, /\beren\b/gi,
          /\bhavia\b/gi, /\bhavies\b/gi, /\bhaviem\b/gi, /\bhav√≠eu\b/gi, /\bhavien\b/gi,
          /\bestava\b/gi, /\bestaves\b/gi, /\best√†vem\b/gi, /\best√†veu\b/gi, /\bestaven\b/gi
        ];
        const matches = [];
        verbPatterns.forEach(p => { const m = text.match(p); if (m) matches.push(...m); });
        return [...new Set(matches)];
      }

      function highlightVerbForms(frase){
        let out = frase;
        findVerbForms(frase).forEach(v=>{
          out = out.replace(new RegExp(`\\b${escapeRegExp(v)}\\b`, "gi"), `<span class="verb-highlight">$&</span>`);
        });
        return out;
      }

      // FUNCI√ì CORREGIDA: matchesPattern que respecta car√†cters catalans
      function matchesPattern(text, pattern, searchTerm, notEndsTerm="", notContainsTerm=""){
        if (!searchTerm) return true;
        const t = text.toLowerCase();
        const s = searchTerm.toLowerCase();
        
        switch(pattern){
          case "anywhere": return t.includes(s);
          case "exact": {
            // CORRECCI√ì: Regex que considera car√†cters catalans
            const exactRegex = new RegExp(`(^|[^a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑])${escapeRegExpForSearch(s)}(?![a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑])`, 'i');
            return exactRegex.test(text);
          }
          case "starts": {
            // Paraules que comencen amb el text buscat
            const startsRegex = new RegExp(`\\b${escapeRegExpForSearch(s)}`, 'i');
            const words = t.match(new RegExp(`\\b${escapeRegExpForSearch(s)}[a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑]*`, 'gi'));
            return words && words.length > 0;
          }
          case "ends": {
            // Paraules que acaben amb el text buscat
            const endsRegex = new RegExp(`${escapeRegExpForSearch(s)}\\b`, 'i');
            const words = t.match(new RegExp(`[a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑]*${escapeRegExpForSearch(s)}\\b`, 'gi'));
            return words && words.length > 0;
          }
          case "notends": {
            const ne = (notEndsTerm || "").toLowerCase();
            if (!ne) return true;
            // Busca paraules que NO acabin amb ne
            const endsRegex = new RegExp(`${escapeRegExpForSearch(ne)}\\b`, 'i');
            const words = t.match(new RegExp(`[a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑]*${escapeRegExpForSearch(ne)}\\b`, 'gi'));
            return !words || words.length === 0;
          }
          case "notcontains": {
            const nc = (notContainsTerm || "").toLowerCase();
            if (!nc) return true;
            return !t.includes(nc);
          }
          default: return t.includes(s);
        }
      }

      function getAdjacentContext(sentence, term, precedingCount, followingCount){
        const regex = new RegExp(escapeRegExp(term), "gi");
        const matches = [...sentence.matchAll(regex)];
        if (!matches.length) return sentence;

        const matchIndex = matches[0].index;
        const words = sentence.split(/\s+/);

        let wordIndex = 0;
        let currentPos = 0;

        for (let i = 0; i < words.length; i++){
          if (currentPos <= matchIndex && matchIndex < currentPos + words[i].length + 1) { wordIndex = i; break; }
          currentPos += words[i].length + 1;
        }

        const start = Math.max(0, wordIndex - precedingCount);
        const end = Math.min(words.length - 1, wordIndex + followingCount);

        const out = [];
        for (let i = start; i <= end; i++){
          out.push(i === wordIndex ? `<span class="highlight">${words[i]}</span>` : words[i]);
        }
        return out.join(" ");
      }

      // Lletres/patrons: m√∫ltiples seq√º√®ncies (separades per espais o comes)
      function parsePatrons(raw){
        return (raw || "").split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
      }
      
      // FUNCI√ì CORREGIDA: Comprovar si una paraula cont√© totes les lletres especificades
      function paraulaCont√©Lletres(paraula, lletres) {
        const paraulaLower = paraula.toLowerCase();
        return lletres.split('').every(lletra => paraulaLower.includes(lletra));
      }

      // NOVA FUNCI√ì: Normalitzar text per a cerca insensible a accents
      function normalizeText(text) {
        return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }

      // NOVA FUNCI√ì CORREGIDA: Analitzar paraules adjacents com a N-GRAMS (grups de paraules)
      function analyzeAdjacentWords(text, searchWord, precedingCount, followingCount) {
        // Netejar el text: eliminar puntuaci√≥, convertir a min√∫scules
        const cleanedText = text.toLowerCase()
          .replace(/[.,!?;:‚Äî()¬ª'"`¬¥]/g, ' ')  // Reempla√ßar puntuaci√≥ amb espais
          .replace(/\s+/g, ' ')  // Normalitzar espais
          .trim();
        
        // Dividir en paraules
        const words = cleanedText.split(/\s+/);
        
        const precedingWords = {};
        const followingWords = {};
        
        // Normalitzar la paraula de cerca
        const normalizedSearchWord = normalizeText(searchWord.toLowerCase());
        
        for (let i = 0; i < words.length; i++) {
          const currentWord = words[i];
          const normalizedCurrentWord = normalizeText(currentWord);
          
          // Comprovar si √©s una coincid√®ncia exacta (insensible a accents)
          if (normalizedCurrentWord === normalizedSearchWord) {
            // PARAULES QUE PRECEDEIXEN: GRUPS DE N PARAULES
            if (precedingCount > 0) {
              // Crear un grup de 'precedingCount' paraules abans
              let precedingGroup = [];
              for (let k = 1; k <= precedingCount; k++) {
                if (i - k >= 0) {
                  const precedingWord = words[i - k];
                  if (precedingWord && precedingWord.trim() !== '') {
                    precedingGroup.unshift(precedingWord); // Afegir al principi
                  }
                }
              }
              
              // Nom√©s comptar si tenim el nombre exacte de paraules demanades
              if (precedingGroup.length === precedingCount) {
                const precedingPhrase = precedingGroup.join(' ');
                precedingWords[precedingPhrase] = (precedingWords[precedingPhrase] || 0) + 1;
              }
            }
            
            // PARAULES QUE SEGUEIXEN: GRUPS DE N PARAULES
            if (followingCount > 0) {
              // Crear un grup de 'followingCount' paraules despr√©s
              let followingGroup = [];
              for (let j = 1; j <= followingCount; j++) {
                if (i + j < words.length) {
                  const followingWord = words[i + j];
                  if (followingWord && followingWord.trim() !== '') {
                    followingGroup.push(followingWord);
                  }
                }
              }
              
              // Nom√©s comptar si tenim el nombre exacte de paraules demanades
              if (followingGroup.length === followingCount) {
                const followingPhrase = followingGroup.join(' ');
                followingWords[followingPhrase] = (followingWords[followingPhrase] || 0) + 1;
              }
            }
          }
        }
        
        return { precedingWords, followingWords };
      }

      // NOVA FUNCI√ì: Mostrar an√†lisi de paraules adjacents
      function renderAdjacentWordsAnalysis(precedingWords, followingWords, searchWord, precedingCount, followingCount) {
        // Amagar el panell si no hi ha dades
        if (Object.keys(precedingWords).length === 0 && Object.keys(followingWords).length === 0) {
          el.adjacentWordsPanel.style.display = "none";
          return;
        }
        
        // Mostrar el panell
        el.adjacentWordsPanel.style.display = "block";
        
        // Actualitzar la paraula de cerca als t√≠tols
        el.precedingSearchWord.textContent = searchWord;
        el.followingSearchWord.textContent = searchWord;
        
        // Netejar llistes anteriors
        el.precedingWordsList.innerHTML = "";
        el.followingWordsList.innerHTML = "";
        
        // Processar paraules que precedeixen
        if (Object.keys(precedingWords).length > 0) {
          // Ordenar per freq√º√®ncia (m√©s alt a m√©s baix) i despr√©s alfab√®ticament
          const sortedPreceding = Object.entries(precedingWords)
            .sort((a, b) => {
              if (b[1] !== a[1]) return b[1] - a[1]; // Ordenar per freq√º√®ncia descendent
              return a[0].localeCompare(b[0]); // Ordenar alfab√®ticament
            });
          
          el.precedingWordsCount.textContent = sortedPreceding.length;
          
          sortedPreceding.forEach(([phrase, count]) => {
            const item = document.createElement("div");
            item.className = "adjacent-word-item";
            item.innerHTML = `
              <span class="adjacent-word-text">${phrase}</span>
              <span class="adjacent-word-count">${count}</span>
            `;
            el.precedingWordsList.appendChild(item);
          });
        } else {
          el.precedingWordsCount.textContent = "0";
          el.precedingWordsList.innerHTML = '<div class="adjacent-words-empty">No hi ha dades</div>';
        }
        
        // Processar paraules que segueixen
        if (Object.keys(followingWords).length > 0) {
          // Ordenar per freq√º√®ncia (m√©s alt a m√©s baix) i despr√©s alfab√®ticament
          const sortedFollowing = Object.entries(followingWords)
            .sort((a, b) => {
              if (b[1] !== a[1]) return b[1] - a[1]; // Ordenar per freq√º√®ncia descendent
              return a[0].localeCompare(b[0]); // Ordenar alfab√®ticament
            });
          
          el.followingWordsCount.textContent = sortedFollowing.length;
          
          sortedFollowing.forEach(([phrase, count]) => {
            const item = document.createElement("div");
            item.className = "adjacent-word-item";
            item.innerHTML = `
              <span class="adjacent-word-text">${phrase}</span>
              <span class="adjacent-word-count">${count}</span>
            `;
            el.followingWordsList.appendChild(item);
          });
        } else {
          el.followingWordsCount.textContent = "0";
          el.followingWordsList.innerHTML = '<div class="adjacent-words-empty">No hi ha dades</div>';
        }
        
        // Informaci√≥ sobre el rang analitzat
        let infoText = "";
        if (precedingCount === 1 && followingCount === 1) {
          infoText = `Analitzant 1 paraula abans i 1 paraula despr√©s de "${searchWord}"`;
        } else {
          infoText = `Analitzant grups de ${precedingCount} paraula(s) abans i ${followingCount} paraula(s) despr√©s de "${searchWord}"`;
        }
        
        const infoElement = document.createElement("div");
        infoElement.className = "adjacent-control-label";
        infoElement.style.marginTop = "10px";
        infoElement.style.fontSize = "11px";
        infoElement.style.color = "var(--muted)";
        infoElement.textContent = infoText;
        
        // Assegurar-nos que la informaci√≥ no es dupliqui
        const existingInfo = el.adjacentWordsPanel.querySelector(".range-info");
        if (existingInfo) existingInfo.remove();
        
        infoElement.classList.add("range-info");
        el.adjacentWordsPanel.appendChild(infoElement);
      }

      // Results render - VERSI√ì SIMPLIFICADA (nom√©s frases)
      function renderEmpty(msg){
        el.resultsList.innerHTML = `<div class="empty">${msg}</div>`;
        el.resultsCount.textContent = "0";
        el.adjacentWordsPanel.style.display = "none";
      }

      function renderResults(results, searchDescription){
        el.resultsList.innerHTML = "";
        el.resultsCount.textContent = results.length;

        if (!results.length){
          el.resultsList.innerHTML = `<div class="empty">${searchDescription}</div>`;
          el.adjacentWordsPanel.style.display = "none";
          return;
        }

        // Versi√≥ simplificada: nom√©s mostrem les frases
        results.forEach((r, idx) => {
          const node = document.createElement("div");
          node.className = "result";
          
          // NOM√âS la frase (amb highlights si estan activats)
          node.innerHTML = `
            <div class="result-body">${r.extracted}</div>
          `;
          
          el.resultsList.appendChild(node);
        });
      }

      // Main extraction - MODIFICAT: Sempre frase completa
      function extractSentences(){
        setBusy(true, "Analitzant text‚Ä¶");

        setTimeout(() => {
          try{
            const text = el.inputText.value.trim();
            if (!text){
              renderEmpty("Introdueix un text o carrega un fitxer.");
              return;
            }

            const searchTypeValue = el.searchType.value;
            const matchPatternValue = el.matchPattern.value;
            const searchTextValue = document.getElementById("searchText").value.trim();
            const notEndsText = document.getElementById("notEndsWithText").value.trim();
            const notContainsTextValue = document.getElementById("notContainsText").value.trim();
            const lletresEspecifiques = document.getElementById("lletresEspecifiques").value.trim().toLowerCase();

            // SEMPRE frase completa (999 paraules abans i despr√©s = tota la frase)
            const precedingWords = 999;
            const followingWords = 999;
            const minWords = parseInt(document.getElementById("minWords").value);
            const maxWords = parseInt(document.getElementById("maxWords").value);

            const highlightElements = document.getElementById("category1").checked;
            const includeSyllables = document.getElementById("category2").checked;

            // NOVES VARIABLES: Paraules adjacents
            const enableAdjacentWords = el.enableAdjacentWords.checked;
            const adjacentPrecedingCount = enableAdjacentWords ? parseInt(el.adjacentPrecedingCount.value) : 1;
            const adjacentFollowingCount = enableAdjacentWords ? parseInt(el.adjacentFollowingCount.value) : 1;

            const sentences = splitIntoSentences(text);
            const results = [];
            let searchDescription = "";

            sentences.forEach(sentence => {
              const sentenceTrimmed = sentence.trim();
              const wordCount = (sentenceTrimmed.split(/\s+/)).length;
              if (wordCount < minWords || wordCount > maxWords) return;

              let sentenceMatches = false;
              let matchedTerms = [];
              let matchedTerm = "";

              if (searchTypeValue === "text"){
                sentenceMatches = matchesPattern(sentenceTrimmed, matchPatternValue, searchTextValue, notEndsText, notContainsTextValue);
                if (sentenceMatches){
                  matchedTerm = searchTextValue;
                  matchedTerms = searchTextValue ? [searchTextValue] : [];
                }
              } else if (searchTypeValue === "esdruixoles"){
                const esd = obtenirEsdruixolesDeFrase(sentenceTrimmed);
                if (esd.length){
                  let filtered = esd;
                  if (lletresEspecifiques){
                    filtered = esd.filter(p => paraulaCont√©Lletres(p, lletresEspecifiques));
                  }
                  if (filtered.length){
                    sentenceMatches = true;
                    matchedTerms = filtered;
                    matchedTerm = filtered[0];
                  }
                }
              } else if (searchTypeValue === "temps" || searchTypeValue === "verb"){
                const terms = (searchTypeValue === "temps") ? findTimeExpressions(text) : findVerbForms(text);
                for (const term of terms){
                  if (matchesPattern(sentenceTrimmed, matchPatternValue, term)){
                    sentenceMatches = true;
                    matchedTerm = term;
                    matchedTerms = [term];
                    break;
                  }
                }
              }

              if (!sentenceMatches) return;

              let processedSentence = sentenceTrimmed;

              if (highlightElements){
                if (searchTypeValue === "esdruixoles") {
                  // Aplicar highlight a les esdr√∫ixoles (VERSI√ì CORREGIDA)
                  processedSentence = highlightEsdruixoles(sentenceTrimmed);
                  
                  // Destacar les lletres espec√≠fiques dins les paraules esdr√∫ixoles
                  if (lletresEspecifiques && matchedTerms.length > 0) {
                    processedSentence = highlightLletresEnEsdruixoles(
                      processedSentence, 
                      lletresEspecifiques, 
                      matchedTerms
                    );
                  }
                } else if (searchTypeValue === "temps") {
                  processedSentence = highlightTimeExpressions(processedSentence);
                } else if (searchTypeValue === "verb") {
                  processedSentence = highlightVerbForms(processedSentence);
                }
              }

              // VERSI√ì CORREGIDA: Highlight segons el patr√≥ de cerca
              if (searchTypeValue === "text" && searchTextValue){
                // Diferents maneres de destacar segons el patr√≥
                if (matchPatternValue === "exact") {
                  // Per coincid√®ncia exacta: nom√©s paraules completes amb car√†cters catalans
                  const exactRegex = new RegExp(`(^|[^a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑])(${escapeRegExpForSearch(searchTextValue)})(?![a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑])`, "gi");
                  processedSentence = processedSentence.replace(exactRegex, `$1<span class="highlight">$2</span>`);
                } else if (matchPatternValue === "starts") {
                  // Per comen√ßa per: paraules que comencen amb...
                  const startsRegex = new RegExp(`\\b(${escapeRegExpForSearch(searchTextValue)}[a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑]*)`, "gi");
                  processedSentence = processedSentence.replace(startsRegex, `<span class="highlight">$1</span>`);
                } else if (matchPatternValue === "ends") {
                  // Per acaba en: paraules que acaben amb...
                  const endsRegex = new RegExp(`([a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß¬∑]*${escapeRegExpForSearch(searchTextValue)})\\b`, "gi");
                  processedSentence = processedSentence.replace(endsRegex, `<span class="highlight">$1</span>`);
                } else {
                  // Per "en qualsevol posici√≥": pot ser dins d'una paraula
                  const re = new RegExp(`(${escapeRegExpForSearch(searchTextValue)})`, "gi");
                  processedSentence = processedSentence.replace(re, `<span class="highlight">$1</span>`);
                }
              }

              if (includeSyllables && searchTypeValue === "esdruixoles" && matchedTerms.length){
                const info = matchedTerms.map(p => `${p}: ${processarParaulaSilabes(p)}`).join("; ");
                processedSentence += ` <span class="word-count-info">Sil¬∑labes: ${info}</span>`;
              }

              // NOTA: Ara sempre es mostra la frase completa
              // No cal fer res aqu√≠ - processedSentence ja cont√© la frase sencera

              results.push({
                fullSentence: sentenceTrimmed,
                extracted: processedSentence,
                matchedTerm,
                matchedTerms,
                wordCount,
                lletresEspecifiques
              });
            });

            if (searchTypeValue === "esdruixoles"){
              searchDescription = lletresEspecifiques
                ? `No s'han trobat frases amb paraules esdr√∫ixoles que contenen "${lletresEspecifiques}".`
                : "No s'han trobat frases amb paraules esdr√∫ixoles.";
            } else if (searchTypeValue === "text"){
              searchDescription = searchTextValue
                ? `No s'han trobat frases cercant "${searchTextValue}".`
                : "No s'han trobat frases.";
            } else if (searchTypeValue === "temps"){
              searchDescription = "No s'han trobat frases amb expressions de temps.";
            } else {
              searchDescription = "No s'han trobat frases amb formes verbals.";
            }

            renderResults(results, searchDescription);
            
            // MODIFICAT: Mostrar an√†lisi de paraules adjacents nom√©s quan s'ha activat el checkbox
            if (enableAdjacentWords && searchTypeValue === "text" && searchTextValue) {
              const analysis = analyzeAdjacentWords(text, searchTextValue, adjacentPrecedingCount, adjacentFollowingCount);
              renderAdjacentWordsAnalysis(analysis.precedingWords, analysis.followingWords, searchTextValue, adjacentPrecedingCount, adjacentFollowingCount);
            } else {
              el.adjacentWordsPanel.style.display = "none";
            }
            
            toast("ok", "Extracci√≥ completada", `${results.length} frase(s) trobada/es.`);
          } catch(err){
            console.error(err);
            toast("err", "Error en analitzar", err.message || "S'ha produ√Øt un error.");
          } finally {
            setBusy(false);
          }
        }, 60);
      }

      // Copy
      el.copyResultsBtn.addEventListener("click", async () => {
        const items = el.resultsList.querySelectorAll(".result");
        if (!items.length){
          toast("err", "No hi ha resultats", "Executa una extracci√≥ primer.");
          return;
        }
        let textToCopy = "";
        let idx = 1;

        items.forEach(node => {
          const plain = node.textContent.replace(/\s+/g, " ").trim();
          if (plain) textToCopy += `${plain}\n\n`;
        });

        try{
          await navigator.clipboard.writeText(textToCopy.trim());
          toast("ok", "Copiat al porta-retalls", "Ja ho tens!");
        }catch(err){
          console.error(err);
          toast("err", "No s'ha pogut copiar", "El navegador pot bloquejar el porta-retalls.");
        }
      });

      // Reset
      el.resetBtn.addEventListener("click", () => {
        el.inputText.value = "";
        el.fileInput.value = "";
        el.fileInfo.style.display = "none";
        el.fileInfo.textContent = "";

        document.getElementById("searchText").value = "";
        document.getElementById("lletresEspecifiques").value = "";
        el.searchType.value = "text";
        el.matchPattern.value = "anywhere";
        document.getElementById("notEndsWithText").value = "";
        document.getElementById("notContainsText").value = "";
        document.getElementById("minWords").value = "1";
        document.getElementById("maxWords").value = "50";
        document.getElementById("category1").checked = true;
        document.getElementById("category2").checked = false;
        
        // Restablir opcions de paraules adjacents
        el.enableAdjacentWords.checked = false;
        el.adjacentPrecedingCount.value = "1";
        el.adjacentFollowingCount.value = "1";
        el.adjacentWordsPanel.style.display = "none";

        updateSearchTypeUI();
        updateNegationUI();
        updateAdjacentWordsUI();
        renderEmpty("Quan executis Extreure, aqu√≠ veur√†s les frases filtrades.");
        toast("ok", "Reiniciat", "Opcions restaurades.");
      });

      // Sample + clear text
      el.sampleTextBtn.addEventListener("click", () => {
        el.inputText.value =
`Hi ha vegades que no entenc res del que passa. A vegades que jo recordi, aix√≤ no havia passat mai. Hi ha moltes vegades que penso en aix√≤. De vegades en qu√® m'avorreixo, llegeix. Vegades hi ha coses estranyes. Aquestes vegades que parlem s√≥n importants.`;
        toast("ok", "Text d'exemple", "S'ha carregat un text de prova.");
      });

      el.clearTextBtn.addEventListener("click", () => {
        el.inputText.value = "";
        toast("ok", "Text netejat", "El camp de text √©s buit.");
      });

      // Extract
      el.extractButton.addEventListener("click", extractSentences);

      // Init
      updateSearchTypeUI();
      updateNegationUI();
      updateAdjacentWordsUI();
      setTimeout(extractSentences, 450);
    });
  </script>
</body>
</html>
