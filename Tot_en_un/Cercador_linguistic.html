<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Extractor de Frases ‚Äî Eines ling√º√≠stiques</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --border: rgba(255,255,255,.12);
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --accent: #7c3aed;   /* violeta */
      --accent2:#22c55e;   /* verd */
      --warn: #fb7185;     /* rosa */
      --ring: 0 0 0 3px rgba(124,58,237,.22);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; font-family: var(--sans); }
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(124,58,237,.28), transparent 60%),
        radial-gradient(1000px 600px at 90% 15%, rgba(34,197,94,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 95%, rgba(251,113,133,.14), transparent 55%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 22px;
    }

    .app{
      max-width: 1240px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 18px;
      align-items: start;
    }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
    }

    .topbar{
      max-width: 1240px;
      margin: 0 auto 18px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 16px;
      border: 1px solid var(--border);
      background: linear-gradient(to right, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex; align-items:center; gap: 12px;
    }
    .logo{
      width: 42px; height: 42px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(34,197,94,.75));
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .brand h1{
      margin:0;
      font-size: 16px;
      letter-spacing: .2px;
      line-height: 1.2;
    }
    .brand p{
      margin: 2px 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .quick{
      display:flex; align-items:center; gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    /* Cards */
    .card{
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .card-header{
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,.04);
    }
    .card-title{
      margin:0;
      font-size: 13px;
      letter-spacing: .3px;
      text-transform: uppercase;
      color: rgba(255,255,255,.78);
    }
    .card-body{
      padding: 16px;
    }

    /* Form UI */
    .field{ margin-bottom: 14px; }
    label{
      display:block;
      margin-bottom: 6px;
      font-size: 12px;
      color: rgba(255,255,255,.78);
    }
    .hint{
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
    }

    input[type="text"], input[type="number"], select, textarea{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(10,16,30,.55);
      color: var(--text);
      outline: none;
      transition: .15s;
    }
    textarea{
      min-height: 190px;
      resize: vertical;
      line-height: 1.5;
    }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(124,58,237,.55);
      box-shadow: var(--ring);
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 520px){ .grid2{ grid-template-columns: 1fr; } }

    .sep{
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    /* Buttons */
    .btn{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      transition: .15s;
      font-weight: 600;
      font-size: 13px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .btn:active{ transform: translateY(0); }
    .btn:focus-visible{ outline: none; box-shadow: var(--ring); }

    .btn-primary{
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(124,58,237,.55));
      border-color: rgba(124,58,237,.45);
    }
    .btn-primary:hover{ background: linear-gradient(135deg, rgba(124,58,237,1), rgba(124,58,237,.65)); }
    .btn-ghost{
      background: transparent;
    }
    .btn-danger{
      background: linear-gradient(135deg, rgba(251,113,133,.95), rgba(251,113,133,.55));
      border-color: rgba(251,113,133,.45);
    }

    .btn[disabled]{
      opacity:.55;
      cursor:not-allowed;
      transform:none !important;
    }

    .pillrow{
      display:flex; gap: 10px; flex-wrap: wrap;
    }

    /* Dropzone */
    .dropzone{
      border: 1px dashed rgba(255,255,255,.28);
      background: rgba(255,255,255,.04);
      border-radius: 18px;
      padding: 14px;
      display:flex;
      flex-direction: column;
      gap: 10px;
      cursor: pointer;
      transition:.15s;
    }
    .dropzone:hover{ background: rgba(255,255,255,.06); }
    .dropzone.dragover{
      border-color: rgba(34,197,94,.7);
      background: rgba(34,197,94,.08);
      transform: scale(1.01);
    }
    .dz-top{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .dz-title{
      display:flex; flex-direction: column; gap: 2px;
    }
    .dz-title strong{ font-size: 13px; }
    .dz-title span{ font-size: 12px; color: var(--muted); }
    .fileinfo{
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.85);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    /* Check/radio */
    .checks{ display:flex; flex-direction: column; gap: 10px; }
    .check{
      display:flex; gap: 10px; align-items: flex-start;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(255,255,255,.04);
    }
    .check input{ margin-top: 2px; }
    .check b{ font-size: 13px; display:block; }
    .check small{ color: var(--muted); font-size: 12px; }

    /* Results */
    .results-toolbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .count-badge{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.86);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
    }

    .results-list{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
      max-height: 560px;
      overflow: auto;
      padding-right: 4px;
    }

    .result{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      border-radius: 18px;
      padding: 12px;
    }
    .result-head{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 8px;
      color: rgba(255,255,255,.72);
      font-size: 12px;
      margin-bottom: 8px;
    }
    .result-body{
      font-size: 14px;
      line-height: 1.6;
      color: rgba(255,255,255,.92);
    }
    .result-meta{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
      font-style: italic;
    }

    .empty{
      padding: 22px 14px;
      border: 1px dashed rgba(255,255,255,.24);
      border-radius: 18px;
      color: var(--muted);
      text-align:center;
    }

    /* Highlights */
    .highlight{ background: rgba(255,249,196,.92); color: #111827; padding: 1px 4px; border-radius: 6px; font-weight: 700; }
    .esdruixola-highlight{ background:#ff9800; color:#111827; padding:1px 4px; border-radius:6px; font-weight:900; }
    .temps-highlight{ background:#22c55e; color:#052e12; padding:1px 4px; border-radius:6px; font-weight:900; }
    .verb-highlight{ background:#a855f7; color:#1f0930; padding:1px 4px; border-radius:6px; font-weight:900; }

    .word-count-info{
      display:inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.78);
      font-size: 12px;
      font-family: var(--mono);
    }

    /* Sticky action footer (mobile-friendly) */
    .sticky-actions{
      position: sticky;
      bottom: 14px;
      padding: 12px;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-top: 14px;
    }
    .sticky-actions .btn{ flex: 1; justify-content: center; min-width: 140px; }

    /* Loading + toast */
    .loading{
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      font-size: 12px;
      align-items:center;
      gap: 10px;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius: 999px;
      background: var(--accent2);
      box-shadow: 0 0 0 6px rgba(34,197,94,.15);
      animation: pulse 1.2s infinite ease-in-out;
    }
    @keyframes pulse{
      0%,100%{ transform: scale(1); opacity:.9 }
      50%{ transform: scale(1.2); opacity:.55 }
    }

    .toast{
      position: fixed;
      top: 16px;
      right: 16px;
      max-width: min(520px, 92vw);
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      display:none;
      z-index: 999;
      font-size: 13px;
    }
    .toast.ok{ border-color: rgba(34,197,94,.35); }
    .toast.err{ border-color: rgba(251,113,133,.45); }
    .toast b{ display:block; margin-bottom:2px; }
    .toast span{ color: var(--muted); font-size: 12px; }

    .kbd{
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.82);
    }
  </style>
</head>

<body>
  <div id="toast" class="toast"></div>

  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Extractor de Frases</h1>
        <p>Filtres ling√º√≠stics (esdr√∫ixoles, temps, verbs) + context i longitud</p>
      </div>
    </div>
    <div class="quick">
      <span class="kbd">PDF/TXT</span>
      <span class="kbd">Ctrl/Cmd + C</span>
      <span class="kbd">Resultats</span>
    </div>
  </div>

  <div class="app">
    <!-- SIDEBAR: Entrada + Filtres -->
    <aside class="card">
      <div class="card-header">
        <h2 class="card-title">Entrada & Filtres</h2>
        <div id="loadingIndicator" class="loading" aria-live="polite">
          <div class="dot" aria-hidden="true"></div>
          <div>Processant‚Ä¶</div>
        </div>
      </div>

      <div class="card-body">
        <!-- Dropzone -->
        <div class="field">
          <div id="dropArea" class="dropzone" tabindex="0" role="button" aria-label="Arrossega un fitxer o fes clic per seleccionar-ne un">
            <div class="dz-top">
              <div class="dz-title">
                <strong>Carrega un fitxer</strong>
                <span>Arrossega aqu√≠ o fes clic (PDF o TXT)</span>
              </div>
              <div class="pillrow">
                <button type="button" class="btn btn-ghost" id="selectFileBtn">üìé Seleccionar</button>
                <button type="button" class="btn btn-ghost" id="clearFileBtn">üßπ Netejar</button>
              </div>
            </div>
            <input type="file" id="fileInput" style="display:none" accept=".pdf,.txt" />
            <div id="fileInfo" class="fileinfo"></div>
          </div>
        </div>

        <!-- Text -->
        <div class="field">
          <label for="inputText">Text a analitzar</label>
          <textarea id="inputText" placeholder="Enganxa aqu√≠ el text o carrega un PDF/TXT‚Ä¶">L'√†via d'en Pere menja p√®ls de cot√≥ mentre canta una can√ß√≥ esdr√∫ixola. Avui fa un dia pluj√≥s i molt vent√≥s, per√≤ dem√† ser√† diferent. Els n√∫vols omplen el cel gris i amena√ßador. La M√≤nica i el seu germ√† viatgen cap a Barcelona per visitar els seus cosins. √âs fant√†stic quan tot surt b√© al final. Vam anar a comprar pa, llet i galetes al supermercat. La m√∫sica cl√†ssica em relaxa profundament. El tel√®fon sona constantment. √âs pr√†cticament impossible no escoltar-lo. Les paraules esdr√∫ixoles s√≥n divertides. L'√®tica i l'√©tica s√≥n coses diferents. La br√∫ixola i l'√†ngel s√≥n paraules esdr√∫ixoles. √âs fant√†stic i pr√†ctic. La m√∫sica i la pr√†ctica s√≥n importants. La fru√Øci√≥ √©s una paraula plana, no esdr√∫ixola. L'√®tica a muntanya √©s important.</textarea>
          <div class="pillrow" style="margin-top:10px;">
            <button type="button" class="btn" id="sampleTextBtn">‚ú® Exemple</button>
            <button type="button" class="btn" id="clearTextBtn">üóëÔ∏è Buida</button>
          </div>
        </div>

        <div class="sep"></div>

        <!-- Cerca -->
        <div class="field">
          <label for="searchType">Tipus de cerca</label>
          <select id="searchType">
            <option value="text">Cadena de text</option>
            <option value="esdruixoles">Paraules esdr√∫ixoles</option>
            <option value="temps">Expressions de temps</option>
            <option value="verb">Formes verbals</option>
          </select>
        </div>

        <div class="grid2">
          <div class="field" id="textSearchGroup">
            <label for="searchText">Text a buscar</label>
            <input type="text" id="searchText" placeholder="Ex: m√∫sica, Barcelona, etc."/>
            <div class="hint">Deixa buit per extreure totes les frases.</div>
          </div>

          <div class="field" id="lletresEspecifiquesGroup" style="display:none;">
            <label for="lletresEspecifiques">Seq√º√®ncia dins esdr√∫ixoles</label>
            <input type="text" id="lletresEspecifiques" placeholder="Ex: pr, l¬∑l, ment"/>
            <div class="hint">Pots posar-ne m√©s d'una: <span class="kbd">pr, l¬∑l</span></div>
          </div>
        </div>

        <div class="field">
          <label for="matchPattern">Patr√≥</label>
          <select id="matchPattern">
            <option value="anywhere">En qualsevol posici√≥</option>
            <option value="exact">Coincid√®ncia exacta</option>
            <option value="starts">Comen√ßada per</option>
            <option value="ends">Acabada en</option>
            <option value="notends">No acabada en</option>
            <option value="notcontains">Que no contingui</option>
          </select>

          <div class="grid2" style="margin-top:10px;">
            <div class="field" id="notEndsWithInput" style="display:none; margin:0;">
              <label for="notEndsWithText">No acaba amb</label>
              <input type="text" id="notEndsWithText" placeholder="Ex: ment, ci√≥‚Ä¶"/>
            </div>

            <div class="field" id="notContainsInput" style="display:none; margin:0;">
              <label for="notContainsText">No cont√©</label>
              <input type="text" id="notContainsText" placeholder="Ex: l¬∑l, gua‚Ä¶"/>
            </div>
          </div>
        </div>

        <div class="sep"></div>

        <div class="field">
          <label>Opcions</label>
          <div class="checks">
            <div class="check">
              <input type="checkbox" id="category1" checked/>
              <div>
                <b>Destacar coincid√®ncies</b>
                <small>Marca en color les paraules trobades.</small>
              </div>
            </div>
            <div class="check">
              <input type="checkbox" id="category2"/>
              <div>
                <b>Incloure marques sil¬∑l√†biques</b>
                <small>Mostra la separaci√≥ en s√≠l¬∑labes (nom√©s en esdr√∫ixoles).</small>
              </div>
            </div>
          </div>
        </div>

        <div class="field">
          <label>Extensi√≥ del fragment</label>
          <div class="checks">
            <div class="check">
              <input type="radio" id="allPhrase" name="phraseScope" checked/>
              <div>
                <b>Tota la frase</b>
                <small>Retorna la frase completa.</small>
              </div>
            </div>
            <div class="check">
              <input type="radio" id="adjacentWords" name="phraseScope"/>
              <div>
                <b>Paraules adjacents</b>
                <small>Retorna nom√©s un context al voltant de la coincid√®ncia.</small>
              </div>
            </div>
          </div>

          <div id="adjacentWordsControls" style="display:none; margin-top:10px;">
            <div class="grid2">
              <div class="field" style="margin:0;">
                <label for="precedingWords">Abans</label>
                <input type="number" id="precedingWords" value="0" min="0" max="10"/>
              </div>
              <div class="field" style="margin:0;">
                <label for="followingWords">Despr√©s</label>
                <input type="number" id="followingWords" value="1" min="0" max="10"/>
              </div>
            </div>
          </div>
        </div>

        <div class="field">
          <label>Longitud (paraules per frase)</label>
          <div class="grid2">
            <div class="field" style="margin:0;">
              <label for="minWords">M√≠nim</label>
              <input type="number" id="minWords" value="1" min="1" max="50"/>
            </div>
            <div class="field" style="margin:0;">
              <label for="maxWords">M√†xim</label>
              <input type="number" id="maxWords" value="50" min="1" max="100"/>
            </div>
          </div>
        </div>

        <div class="sticky-actions">
          <button type="button" class="btn btn-primary" id="extractButton">üîé Extreure</button>
          <button type="button" class="btn" id="copyResultsBtn">üìã Copiar</button>
          <button type="button" class="btn btn-danger" id="resetBtn">‚Ü©Ô∏è Reiniciar</button>
        </div>
      </div>
    </aside>

    <!-- MAIN: Resultats -->
    <main class="card">
      <div class="card-header">
        <h2 class="card-title">Resultats</h2>
        <div class="results-toolbar">
          <div class="count-badge">Frases trobades: <span id="resultsCount">0</span></div>
        </div>
      </div>
      <div class="card-body">
        <div id="resultsList" class="results-list">
          <div class="empty">Quan executis <b>Extreure</b>, aqu√≠ veur√†s les frases filtrades.</div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js";

    document.addEventListener("DOMContentLoaded", () => {
      // DOM
      const el = {
        searchType: document.getElementById("searchType"),
        extractButton: document.getElementById("extractButton"),
        resultsList: document.getElementById("resultsList"),
        resultsCount: document.getElementById("resultsCount"),
        inputText: document.getElementById("inputText"),
        matchPattern: document.getElementById("matchPattern"),
        loadingIndicator: document.getElementById("loadingIndicator"),

        fileInput: document.getElementById("fileInput"),
        selectFileBtn: document.getElementById("selectFileBtn"),
        dropArea: document.getElementById("dropArea"),
        fileInfo: document.getElementById("fileInfo"),
        clearFileBtn: document.getElementById("clearFileBtn"),

        sampleTextBtn: document.getElementById("sampleTextBtn"),
        clearTextBtn: document.getElementById("clearTextBtn"),
        copyResultsBtn: document.getElementById("copyResultsBtn"),
        resetBtn: document.getElementById("resetBtn"),

        textSearchGroup: document.getElementById("textSearchGroup"),
        lletresEspecifiquesGroup: document.getElementById("lletresEspecifiquesGroup"),

        allPhraseRadio: document.getElementById("allPhrase"),
        adjacentWordsRadio: document.getElementById("adjacentWords"),
        adjacentWordsControls: document.getElementById("adjacentWordsControls"),

        notEndsWithInput: document.getElementById("notEndsWithInput"),
        notContainsInput: document.getElementById("notContainsInput"),

        toast: document.getElementById("toast"),
      };

      const controlsToDisable = [
        el.extractButton, el.copyResultsBtn, el.resetBtn,
        el.selectFileBtn, el.clearFileBtn, el.sampleTextBtn, el.clearTextBtn
      ];

      function setBusy(isBusy, message = "Processant‚Ä¶") {
        controlsToDisable.forEach(b => b.disabled = isBusy);
        el.loadingIndicator.style.display = isBusy ? "inline-flex" : "none";
        if (isBusy) el.loadingIndicator.querySelector("div:last-child").textContent = message;
      }

      function toast(kind, title, detail = "", ms = 3200){
        el.toast.className = "toast " + (kind === "err" ? "err" : "ok");
        el.toast.innerHTML = `<b>${title}</b><span>${detail}</span>`;
        el.toast.style.display = "block";
        setTimeout(() => (el.toast.style.display = "none"), ms);
      }

      // UI: show/hide
      function updateSearchTypeUI(){
        const v = el.searchType.value;
        if (v === "esdruixoles") {
          el.textSearchGroup.style.display = "none";
          el.lletresEspecifiquesGroup.style.display = "block";
        } else {
          el.textSearchGroup.style.display = "block";
          el.lletresEspecifiquesGroup.style.display = "none";
        }
      }

      function updateNegationUI(){
        el.notEndsWithInput.style.display = "none";
        el.notContainsInput.style.display = "none";
        if (el.matchPattern.value === "notends") el.notEndsWithInput.style.display = "block";
        if (el.matchPattern.value === "notcontains") el.notContainsInput.style.display = "block";
      }

      function updateAdjacentUI(){
        el.adjacentWordsControls.style.display = el.adjacentWordsRadio.checked ? "block" : "none";
      }

      el.searchType.addEventListener("change", () => { updateSearchTypeUI(); updateNegationUI(); });
      el.matchPattern.addEventListener("change", updateNegationUI);
      el.allPhraseRadio.addEventListener("change", updateAdjacentUI);
      el.adjacentWordsRadio.addEventListener("change", updateAdjacentUI);

      // Dropzone clicks (avoid button conflicts)
      el.dropArea.addEventListener("click", (e) => {
        if (e.target.closest("button")) return;
        el.fileInput.click();
      });
      el.dropArea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          el.fileInput.click();
        }
      });
      el.selectFileBtn.addEventListener("click", (e) => { e.stopPropagation(); el.fileInput.click(); });
      el.clearFileBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        el.fileInput.value = "";
        el.fileInfo.style.display = "none";
        el.fileInfo.textContent = "";
        toast("ok", "Fitxer eliminat", "S'ha netejat la selecci√≥.");
      });

      // Drag and drop
      ["dragenter","dragover","dragleave","drop"].forEach(evt => {
        el.dropArea.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); });
      });
      ["dragenter","dragover"].forEach(evt => {
        el.dropArea.addEventListener(evt, () => el.dropArea.classList.add("dragover"));
      });
      ["dragleave","drop"].forEach(evt => {
        el.dropArea.addEventListener(evt, () => el.dropArea.classList.remove("dragover"));
      });
      el.dropArea.addEventListener("drop", (e) => {
        const files = e.dataTransfer.files;
        if (files && files.length) {
          el.fileInput.files = files;
          handleFileSelect();
        }
      });

      el.fileInput.addEventListener("change", handleFileSelect);

      async function handleFileSelect(){
        if (!el.fileInput.files.length) return;
        const file = el.fileInput.files[0];
        const ext = file.name.split(".").pop().toLowerCase();
        if (ext !== "pdf" && ext !== "txt"){
          toast("err", "Fitxer no v√†lid", "Nom√©s PDF o TXT.");
          return;
        }

        el.fileInfo.style.display = "block";
        el.fileInfo.textContent = `Fitxer: ${file.name} (${formatFileSize(file.size)})`;

        setBusy(true, "Carregant fitxer‚Ä¶");
        try{
          let textContent = "";
          if (ext === "pdf") textContent = await extractTextFromPDF(file);
          else textContent = await extractTextFromTXT(file);

          el.inputText.value = textContent.trim();
          toast("ok", "Fitxer carregat", `S'ha importat el contingut (${ext.toUpperCase()}).`);
        }catch(err){
          console.error(err);
          toast("err", "Error en carregar", err.message || "No s'ha pogut llegir el fitxer.");
        }finally{
          setBusy(false);
        }
      }

      async function extractTextFromPDF(file){
        const buffer = await file.arrayBuffer();
        const typedArray = new Uint8Array(buffer);
        const pdf = await pdfjsLib.getDocument(typedArray).promise;

        let allText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(" ");
          allText += pageText + " ";
        }
        return allText;
      }

      async function extractTextFromTXT(file){
        return await file.text();
      }

      function formatFileSize(bytes){
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes","KB","MB","GB"];
        const i = Math.floor(Math.log(bytes)/Math.log(k));
        return parseFloat((bytes/Math.pow(k,i)).toFixed(2)) + " " + sizes[i];
      }

      // Text helpers
      function escapeRegExp(str){ return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

      function splitIntoSentences(text){
        const protectedText = text.replace(/l[¬∑.‚Ä¢]l/gi, "L_GEMINADA");
        const sentences = protectedText.split(/(?<=[.!?])\s+/);
        return sentences.map(s => s.replace(/L_GEMINADA/gi, "l¬∑l")).map(s => s.trim()).filter(Boolean);
      }

      // S√çL¬∑LABES (tal com el teu)
      function processarParaulaSilabes(paraula) {
        let paraulaProcessada = paraula;
        let canvi;

        paraulaProcessada = paraulaProcessada.replace(/arg√º(eix|i|√≠)/gi, 'arg√º-$1');
        paraulaProcessada = paraulaProcessada.replace(/(M√†ri|S√≠ri)us($)/gi, '$1-us$2');
        paraulaProcessada = paraulaProcessada.replace(/l¬∑l/gi, 'l-l');

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])([bcdfghjklmnpqrstvwxyz√ß])([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, c, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + c + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([a-z√ß√†√®√©√≠√Ø√≤√≥√∫√º])(ll|ny|kh|bl|br|cl|cr|dr|fl|fr|gl|gr|pl|pr|tr)([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, cons, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + cons + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])([bcdfghjklmnpqrstvwxyz√ß]{2,})([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, cons, v2) => {
              if (!match.includes('-')) {
                canvi = true;
                const pre = cons.substring(0, cons.length - 1);
                const last = cons.substring(cons.length - 1);
                return v1 + pre + '-' + last + v2;
              }
              return match;
            }
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        paraulaProcessada = paraulaProcessada.replace(/([gq])u([aeiou√†√®√©√≠√≤√≥√∫√º])/gi, '$1*u*$2');

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([a√†e√©√®i√≠o√≤√≥u√∫])([iu])([aeiou])([iu])/gi,
            (match, v1, iu1, v2, iu2) => (!match.includes('-') ? (canvi = true, v1 + '-' + iu1 + '*' + v2 + iu2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou√†√®√©√≠√≤√≥√∫])([iu])([aeiou√†√®√©√≠√Ø√≤√≥√∫√º])/gi,
            (match, v1, iu, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + iu + '*' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou])([√†√®√©√≠√≤√≥√∫√Ø√º])/gi,
            (match, v1, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([bcdfgjklmnpqrstvwxyz√ß])([iu])([aeo])/gi,
            (match, c, iu, v) => (!match.includes('-') ? (canvi = true, c + iu + '-' + v) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeo√†√®√©√≤√≥])([aeo√†√®√©√≤√≥])/gi,
            (match, v1, v2) => (!match.includes('-') ? (canvi = true, v1 + '-' + v2) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        do {
          canvi = false;
          const novaParaula = paraulaProcessada.replace(/([aeiou])um($|s$)/gi,
            (match, v, fin) => (!match.includes('-') ? (canvi = true, v + '-um' + fin) : match)
          );
          if (canvi) paraulaProcessada = novaParaula;
        } while (canvi);

        paraulaProcessada = paraulaProcessada.replace(/\*/gi, '');
        paraulaProcessada = paraulaProcessada.replace(/--+/g, '-');
        paraulaProcessada = paraulaProcessada.replace(/^-/, '');

        return paraulaProcessada;
      }

      // FUNCI√ì CORREGIDA: Determinar si una paraula √©s esdr√∫ixola
      function esEsdruixola(paraula) {
        // Neteja la paraula - tractar ap√≤strofs
        const paraulaNeta = paraula.replace(/^[lLdDsSnNtTmM]['‚Äô]|[.,!?;:‚Äî()¬ª]$/gi, '').replace(/[.,!?;:‚Äî()¬ª]$/, '');
        
        // Si la paraula √©s massa curta, no pot ser esdr√∫ixola
        if (paraulaNeta.length < 3) return false;
        
        // Separa la paraula en s√≠l¬∑labes
        const paraulaSeparada = processarParaulaSilabes(paraulaNeta);
        const silabes = paraulaSeparada.split('-').filter(s => s.length > 0);
        
        // Necessita almenys 3 s√≠l¬∑labes per ser esdr√∫ixola
        if (silabes.length < 3) return false;
        
        // Buscar accent a les s√≠l¬∑labes (nom√©s accents reals, no di√®resis)
        for (let i = 0; i < silabes.length; i++) {
          if (/[√†√®√©√≠√≤√≥√∫]/.test(silabes[i])) {
            // Si l'accent est√† a la antepen√∫ltima o abans, √©s esdr√∫ixola
            const posicioDesDelFinal = silabes.length - 1 - i;
            return posicioDesDelFinal >= 2;
          }
        }
        
        return false;
      }

      // FUNCI√ì CORREGIDA: Obtenir totes les paraules esdr√∫ixoles d'una frase
      function obtenirEsdruixolesDeFrase(frase) {
        // Regex per trobar paraules (incloent les amb ap√≤strof)
        const paraules = frase.match(/\b(?:[lLdDsSnNtTmM]['‚Äô])?[a-zA-Z√Ä-√ø√ß√á]+/g) || [];
        const esdruixoles = [];
        
        paraules.forEach(paraula => {
          if (esEsdruixola(paraula)) {
            esdruixoles.push(paraula);
          }
        });
        
        return esdruixoles;
      }

      // FUNCI√ì MILLORADA: Per destacar paraules esdr√∫ixoles sense incloure l'ap√≤strof
      function highlightEsdruixoles(frase) {
        // Obtenir totes les esdr√∫ixoles
        const esdruixoles = obtenirEsdruixolesDeFrase(frase);
        let resultat = frase;
        
        // Ordenar de m√©s llarga a m√©s curta per evitar reempla√ßaments parcials
        esdruixoles.sort((a, b) => b.length - a.length);
        
        // Per a cada esdr√∫ixola, reempla√ßar-la amb highlight
        esdruixoles.forEach(paraula => {
          // Hem de trobar la forma exacta tal com apareix a la frase
          // Aix√≤ inclou ap√≤strofs i altres car√†cters
          const paraulesFrase = frase.match(/\b(?:[lLdDsSnNtTmM]['‚Äô])?[a-zA-Z√Ä-√ø√ß√á]+\b/g) || [];
          
          // Buscar la paraula tal com apareix a la frase
          let paraulaFrase = paraula;
          for (let pf of paraulesFrase) {
            // Comprovar si aquesta paraula de la frase √©s l'esdr√∫ixola
            // Per√≤ neteja primer els ap√≤strofs
            const pfNeta = pf.replace(/^[lLdDsSnNtTmM]['‚Äô]/, '');
            if (pfNeta === paraula.replace(/^[lLdDsSnNtTmM]['']/, '')) {
              paraulaFrase = pf;
              break;
            }
          }
          
          // Escapar car√†cters especials per a regex
          const paraulaEscapada = paraulaFrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          
          // Crear l'highlight nom√©s per la part de la paraula, no l'ap√≤strof
          // Separar l'ap√≤strof inicial de la paraula
          const match = paraulaFrase.match(/^([lLdDsSnNtTmM][''])?(.+)$/);
          if (match) {
            const apostrof = match[1] || '';
            const paraulaSenseApostrof = match[2];
            
            // Si hi ha ap√≤strof, mantenir-lo fora de l'highlight
            if (apostrof) {
              const regex = new RegExp(`(${escapeRegExp(apostrof)}${escapeRegExp(paraulaSenseApostrof)})`, 'g');
              resultat = resultat.replace(regex, 
                `${apostrof}<span class="esdruixola-highlight">${paraulaSenseApostrof}</span>`);
            } else {
              // Sense ap√≤strof, destacar la paraula sencera
              const regex = new RegExp(`\\b${escapeRegExp(paraulaFrase)}\\b`, 'g');
              resultat = resultat.replace(regex, 
                `<span class="esdruixola-highlight">${paraulaFrase}</span>`);
            }
          }
        });
        
        return resultat;
      }

      // FUNCI√ì NOVA: Destacar lletres espec√≠fiques dins les paraules esdr√∫ixoles amb ap√≤strof
      function highlightLletresEnEsdruixoles(frase, lletresEspecifiques, esdruixoles) {
        if (!lletresEspecifiques || !esdruixoles || esdruixoles.length === 0) {
          return frase;
        }
        
        let resultat = frase;
        
        // Per cada paraula esdr√∫ixola
        esdruixoles.forEach(paraula => {
          // Trobar la paraula com apareix a la frase (amb ap√≤strof si el t√©)
          const paraulesFrase = frase.match(/\b(?:[lLdDsSnNtTmM][''])?[a-zA-Z√Ä-√ø√ß√á]+\b/g) || [];
          let paraulaFrase = paraula;
          
          for (let pf of paraulesFrase) {
            const pfNeta = pf.replace(/^[lLdDsSnNtTmM]['']/, '');
            if (pfNeta === paraula.replace(/^[lLdDsSnNtTmM]['']/, '')) {
              paraulaFrase = pf;
              break;
            }
          }
          
          // Separar ap√≤strof si n'hi ha
          const match = paraulaFrase.match(/^([lLdDsSnNtTmM][''])?(.+)$/);
          if (!match) return;
          
          const apostrof = match[1] || '';
          const paraulaSenseApostrof = match[2];
          
          // Crear versi√≥ amb les lletres destacades
          let paraulaDestacada = paraulaSenseApostrof;
          
          // Destacar cada lletra espec√≠fica
          lletresEspecifiques.split('').forEach(lletra => {
            const regex = new RegExp(`(${escapeRegExp(lletra)})`, 'gi');
            paraulaDestacada = paraulaDestacada.replace(regex, 
              `<span style="background-color: #ff5722; color: white; font-weight: bold; padding: 1px 3px; border-radius: 2px;">$1</span>`);
          });
          
          // Reempla√ßar a la frase
          const paraulaCompleta = apostrof + paraulaSenseApostrof;
          const paraulaDestacadaCompleta = apostrof + paraulaDestacada;
          
          const regex = new RegExp(escapeRegExp(paraulaCompleta), 'g');
          resultat = resultat.replace(regex, paraulaDestacadaCompleta);
        });
        
        return resultat;
      }

      function findTimeExpressions(text) {
        const timePatterns = [
          /\bavui\b/gi, /\bdem√†\b/gi, /\bahir\b/gi, /\bsetmana\b/gi, /\bmes\b/gi, /\bany\b/gi,
          /\bdilluns\b/gi, /\bdimarts\b/gi, /\bdimecres\b/gi, /\bdijous\b/gi, /\bdivendres\b/gi,
          /\bdissabte\b/gi, /\bdiumenge\b/gi, /\bmat√≠\b/gi, /\btarda\b/gi, /\bnit\b/gi,
          /\bprimavera\b/gi, /\bestiu\b/gi, /\btardor\b/gi, /\bhivern\b/gi,
          /\bdia\b/gi, /\bhor[ae]\b/gi, /\bminut[os]?\b/gi, /\bsegon[os]?\b/gi
        ];
        const matches = [];
        timePatterns.forEach(p => { const m = text.match(p); if (m) matches.push(...m); });
        return [...new Set(matches)];
      }

      function highlightTimeExpressions(frase){
        let out = frase;
        findTimeExpressions(frase).forEach(expr=>{
          out = out.replace(new RegExp(`\\b${escapeRegExp(expr)}\\b`, "gi"), `<span class="temps-highlight">$&</span>`);
        });
        return out;
      }

      function findVerbForms(text){
        const verbPatterns = [
          /\bvaig\b/gi, /\bvas\b/gi, /\bva\b/gi, /\bvam\b/gi, /\bvau\b/gi, /\bvan\b/gi,
          /\bestic\b/gi, /\best√†s\b/gi, /\best√†\b/gi, /\bestem\b/gi, /\bestau\b/gi, /\bestan\b/gi,
          /\bhe\b/gi, /\bhas\b/gi, /\bha\b/gi, /\bhem\b/gi, /\bheu\b/gi, /\bhan\b/gi,
          /\bs√≥c\b/gi, /\bets\b/gi, /\b√©s\b/gi, /\bsom\b/gi, /\beu\b/gi, /\bs√≥n\b/gi,
          /\bera\b/gi, /\beres\b/gi, /\b√©rem\b/gi, /\b√©reu\b/gi, /\beren\b/gi,
          /\bhavia\b/gi, /\bhavies\b/gi, /\bhaviem\b/gi, /\bhav√≠eu\b/gi, /\bhavien\b/gi,
          /\bestava\b/gi, /\bestaves\b/gi, /\best√†vem\b/gi, /\best√†veu\b/gi, /\bestaven\b/gi
        ];
        const matches = [];
        verbPatterns.forEach(p => { const m = text.match(p); if (m) matches.push(...m); });
        return [...new Set(matches)];
      }

      function highlightVerbForms(frase){
        let out = frase;
        findVerbForms(frase).forEach(v=>{
          out = out.replace(new RegExp(`\\b${escapeRegExp(v)}\\b`, "gi"), `<span class="verb-highlight">$&</span>`);
        });
        return out;
      }

      function matchesPattern(text, pattern, searchTerm, notEndsTerm="", notContainsTerm=""){
        if (!searchTerm) return true;
        const t = text.toLowerCase();
        const s = searchTerm.toLowerCase();
        const words = t.match(/[a-z√†√®√©√≠√Ø√≤√≥√∫√º√ß]+/g) || [];

        switch(pattern){
          case "anywhere": return t.includes(s);
          case "exact": return words.some(w => w === s);
          case "starts": return words.some(w => w.startsWith(s));
          case "ends": return words.some(w => w.endsWith(s));
          case "notends": {
            const ne = (notEndsTerm || "").toLowerCase();
            if (!ne) return true;
            return !words.some(w => w.endsWith(ne));
          }
          case "notcontains": {
            const nc = (notContainsTerm || "").toLowerCase();
            if (!nc) return true;
            return !t.includes(nc);
          }
          default: return t.includes(s);
        }
      }

      function getAdjacentContext(sentence, term, precedingCount, followingCount){
        const regex = new RegExp(escapeRegExp(term), "gi");
        const matches = [...sentence.matchAll(regex)];
        if (!matches.length) return sentence;

        const matchIndex = matches[0].index;
        const words = sentence.split(/\s+/);

        let wordIndex = 0;
        let currentPos = 0;

        for (let i = 0; i < words.length; i++){
          if (currentPos <= matchIndex && matchIndex < currentPos + words[i].length + 1) { wordIndex = i; break; }
          currentPos += words[i].length + 1;
        }

        const start = Math.max(0, wordIndex - precedingCount);
        const end = Math.min(words.length - 1, wordIndex + followingCount);

        const out = [];
        for (let i = start; i <= end; i++){
          out.push(i === wordIndex ? `<span class="highlight">${words[i]}</span>` : words[i]);
        }
        return out.join(" ");
      }

      // Lletres/patrons: m√∫ltiples seq√º√®ncies (separades per espais o comes)
      function parsePatrons(raw){
        return (raw || "").split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
      }
      
      // FUNCI√ì CORREGIDA: Comprovar si una paraula cont√© totes les lletres especificades
      function paraulaCont√©Lletres(paraula, lletres) {
        const paraulaLower = paraula.toLowerCase();
        return lletres.split('').every(lletra => paraulaLower.includes(lletra));
      }

      // Results render
      function renderEmpty(msg){
        el.resultsList.innerHTML = `<div class="empty">${msg}</div>`;
        el.resultsCount.textContent = "0";
      }

      function renderResults(results, searchDescription){
        el.resultsList.innerHTML = "";
        el.resultsCount.textContent = results.length;

        if (!results.length){
          el.resultsList.innerHTML = `<div class="empty">${searchDescription}</div>`;
          return;
        }

        let totalWords = 0;
        let totalMatches = 0;
        const uniques = new Set();

        results.forEach((r, idx) => {
          totalWords += r.wordCount;
          if (r.matchedTerms && r.matchedTerms.length){
            r.matchedTerms.forEach(p => { uniques.add(p); totalMatches++; });
          } else if (r.matchedTerm){
            uniques.add(r.matchedTerm);
            totalMatches++;
          }

          const meta =
            (el.searchType.value === "esdruixoles" && r.matchedTerms?.length)
              ? `Paraules esdr√∫ixoles (${r.matchedTerms.length}): ${r.matchedTerms.map(p=>`"${p}"`).join(", ")}${r.lletresEspecifiques ? ` | Cont√©: "${r.lletresEspecifiques}"` : ""}`
              : (r.matchedTerm ? `Coincid√®ncia: "${r.matchedTerm}"` : "Sense cerca espec√≠fica");

          const node = document.createElement("div");
          node.className = "result";
          node.innerHTML = `
            <div class="result-head">
              <div><b>Frase ${idx+1}</b> ¬∑ ${r.wordCount} paraules</div>
              <div style="font-family:var(--mono);">${r.matchedTerm ? "match" : "ok"}</div>
            </div>
            <div class="result-body">${r.extracted}</div>
            <div class="result-meta">${meta}</div>
          `;
          el.resultsList.appendChild(node);
        });

        // Stats card
        const stats = document.createElement("div");
        stats.className = "result";
        stats.style.background = "rgba(255,255,255,.035)";

        if (el.searchType.value === "esdruixoles"){
          const per = (totalMatches / results.length).toFixed(1);
          stats.innerHTML = `
            <div class="result-head"><div><b>Estad√≠stiques</b></div><div class="count-badge">esdr√∫ixoles</div></div>
            <div class="result-body">
              <div><span class="kbd">${results.length}</span> frases ¬∑ <span class="kbd">${totalWords}</span> paraules totals ¬∑ <span class="kbd">${totalMatches}</span> esdr√∫ixoles (${per}/frase)</div>
              <div style="margin-top:10px; color: var(--muted); font-size:12px;">
                <b style="color:rgba(255,255,255,.75)">Diferents (${uniques.size}):</b> ${Array.from(uniques).join(", ")}
              </div>
            </div>
          `;
        } else {
          const avg = (totalWords / results.length).toFixed(1);
          stats.innerHTML = `
            <div class="result-head"><div><b>Estad√≠stiques</b></div><div class="count-badge">general</div></div>
            <div class="result-body">
              <div><span class="kbd">${results.length}</span> frases ¬∑ <span class="kbd">${totalWords}</span> paraules totals ¬∑ <span class="kbd">${avg}</span> paraules/frase</div>
            </div>
          `;
        }
        el.resultsList.appendChild(stats);
      }

      // Main extraction
      function extractSentences(){
        setBusy(true, "Analitzant text‚Ä¶");

        setTimeout(() => {
          try{
            const text = el.inputText.value.trim();
            if (!text){
              renderEmpty("Introdueix un text o carrega un fitxer.");
              return;
            }

            const searchTypeValue = el.searchType.value;
            const matchPatternValue = el.matchPattern.value;
            const searchTextValue = document.getElementById("searchText").value.trim();
            const notEndsText = document.getElementById("notEndsWithText").value.trim();
            const notContainsTextValue = document.getElementById("notContainsText").value.trim();
            const lletresEspecifiques = document.getElementById("lletresEspecifiques").value.trim().toLowerCase();

            const allPhraseSelected = el.allPhraseRadio.checked;
            const precedingWords = allPhraseSelected ? 999 : parseInt(document.getElementById("precedingWords").value);
            const followingWords = allPhraseSelected ? 999 : parseInt(document.getElementById("followingWords").value);
            const minWords = parseInt(document.getElementById("minWords").value);
            const maxWords = parseInt(document.getElementById("maxWords").value);

            const highlightElements = document.getElementById("category1").checked;
            const includeSyllables = document.getElementById("category2").checked;

            const sentences = splitIntoSentences(text);
            const results = [];
            let searchDescription = "";

            sentences.forEach(sentence => {
              const sentenceTrimmed = sentence.trim();
              const wordCount = (sentenceTrimmed.split(/\s+/)).length;
              if (wordCount < minWords || wordCount > maxWords) return;

              let sentenceMatches = false;
              let matchedTerms = [];
              let matchedTerm = "";

              if (searchTypeValue === "text"){
                sentenceMatches = matchesPattern(sentenceTrimmed, matchPatternValue, searchTextValue, notEndsText, notContainsTextValue);
                if (sentenceMatches){
                  matchedTerm = searchTextValue;
                  matchedTerms = searchTextValue ? [searchTextValue] : [];
                }
              } else if (searchTypeValue === "esdruixoles"){
                const esd = obtenirEsdruixolesDeFrase(sentenceTrimmed);
                if (esd.length){
                  let filtered = esd;
                  if (lletresEspecifiques){
                    filtered = esd.filter(p => paraulaCont√©Lletres(p, lletresEspecifiques));
                  }
                  if (filtered.length){
                    sentenceMatches = true;
                    matchedTerms = filtered;
                    matchedTerm = filtered[0];
                  }
                }
              } else if (searchTypeValue === "temps" || searchTypeValue === "verb"){
                const terms = (searchTypeValue === "temps") ? findTimeExpressions(text) : findVerbForms(text);
                for (const term of terms){
                  if (matchesPattern(sentenceTrimmed, matchPatternValue, term)){
                    sentenceMatches = true;
                    matchedTerm = term;
                    matchedTerms = [term];
                    break;
                  }
                }
              }

              if (!sentenceMatches) return;

              let processedSentence = sentenceTrimmed;

              if (highlightElements){
                if (searchTypeValue === "esdruixoles") {
                  // Aplicar highlight a les esdr√∫ixoles (VERSI√ì MILLORADA)
                  processedSentence = highlightEsdruixoles(sentenceTrimmed);
                  
                  // Destacar les lletres espec√≠fiques dins les paraules esdr√∫ixoles
                  if (lletresEspecifiques && matchedTerms.length > 0) {
                    processedSentence = highlightLletresEnEsdruixoles(
                      processedSentence, 
                      lletresEspecifiques, 
                      matchedTerms
                    );
                  }
                } else if (searchTypeValue === "temps") {
                  processedSentence = highlightTimeExpressions(processedSentence);
                } else if (searchTypeValue === "verb") {
                  processedSentence = highlightVerbForms(processedSentence);
                }
              }

              if (searchTypeValue === "text" && searchTextValue){
                const re = new RegExp(`(${escapeRegExp(searchTextValue)})`, "gi");
                processedSentence = processedSentence.replace(re, `<span class="highlight">$1</span>`);
              }

              if (includeSyllables && searchTypeValue === "esdruixoles" && matchedTerms.length){
                const info = matchedTerms.map(p => `${p}: ${processarParaulaSilabes(p)}`).join("; ");
                processedSentence += ` <span class="word-count-info">Sil¬∑labes: ${info}</span>`;
              }

              if ((precedingWords > 0 || followingWords > 0) && matchedTerm && !allPhraseSelected){
                processedSentence = getAdjacentContext(sentenceTrimmed, matchedTerm, precedingWords, followingWords);
              }

              results.push({
                fullSentence: sentenceTrimmed,
                extracted: processedSentence,
                matchedTerm,
                matchedTerms,
                wordCount,
                lletresEspecifiques
              });
            });

            if (searchTypeValue === "esdruixoles"){
              searchDescription = lletresEspecifiques
                ? `No s'han trobat frases amb paraules esdr√∫ixoles que contenen "${lletresEspecifiques}".`
                : "No s'han trobat frases amb paraules esdr√∫ixoles.";
            } else if (searchTypeValue === "text"){
              searchDescription = searchTextValue
                ? `No s'han trobat frases cercant "${searchTextValue}".`
                : "No s'han trobat frases.";
            } else if (searchTypeValue === "temps"){
              searchDescription = "No s'han trobat frases amb expressions de temps.";
            } else {
              searchDescription = "No s'han trobat frases amb formes verbals.";
            }

            renderResults(results, searchDescription);
            toast("ok", "Extracci√≥ completada", `${results.length} frase(s) trobada/es.`);
          } catch(err){
            console.error(err);
            toast("err", "Error en analitzar", err.message || "S'ha produ√Øt un error.");
          } finally {
            setBusy(false);
          }
        }, 60);
      }

      // Copy
      el.copyResultsBtn.addEventListener("click", async () => {
        const items = el.resultsList.querySelectorAll(".result");
        if (!items.length){
          toast("err", "No hi ha resultats", "Executa una extracci√≥ primer.");
          return;
        }
        let textToCopy = "";
        let idx = 1;

        items.forEach(node => {
          // saltar estad√≠stiques (√∫ltim bloc)
          const head = node.querySelector(".result-head b")?.textContent || "";
          if (head.toLowerCase().includes("estad√≠stiques")) return;
          const plain = node.textContent.replace(/\s+/g, " ").trim();
          if (plain) textToCopy += `${idx++}. ${plain}\n\n`;
        });

        try{
          await navigator.clipboard.writeText(textToCopy.trim());
          toast("ok", "Copiat al porta-retalls", "Ja ho tens!");
        }catch(err){
          console.error(err);
          toast("err", "No s'ha pogut copiar", "El navegador pot bloquejar el porta-retalls.");
        }
      });

      // Reset
      el.resetBtn.addEventListener("click", () => {
        el.inputText.value = "";
        el.fileInput.value = "";
        el.fileInfo.style.display = "none";
        el.fileInfo.textContent = "";

        document.getElementById("searchText").value = "";
        document.getElementById("lletresEspecifiques").value = "";
        el.searchType.value = "text";
        el.matchPattern.value = "anywhere";
        document.getElementById("notEndsWithText").value = "";
        document.getElementById("notContainsText").value = "";
        el.allPhraseRadio.checked = true;
        el.adjacentWordsRadio.checked = false;
        document.getElementById("precedingWords").value = "0";
        document.getElementById("followingWords").value = "1";
        document.getElementById("minWords").value = "1";
        document.getElementById("maxWords").value = "50";
        document.getElementById("category1").checked = true;
        document.getElementById("category2").checked = false;

        updateSearchTypeUI();
        updateNegationUI();
        updateAdjacentUI();
        renderEmpty("Quan executis Extreure, aqu√≠ veur√†s les frases filtrades.");
        toast("ok", "Reiniciat", "Opcions restaurades.");
      });

      // Sample + clear text
      el.sampleTextBtn.addEventListener("click", () => {
        el.inputText.value =
`L'√†via d'en Pere menja p√®ls de cot√≥ mentre canta una can√ß√≥ esdr√∫ixola. Avui fa un dia pluj√≥s i molt vent√≥s, per√≤ dem√† ser√† diferent. Els n√∫vols omplen el cel gris i amena√ßador. La M√≤nica i el seu germ√† viatgen cap a Barcelona per visitar els seus cosins. √âs fant√†stic quan tot surt b√© al final. Vam anar a comprar pa, llet i galetes al supermercat. La m√∫sica cl√†ssica em relaxa profundament. El tel√®fon sona constantment. √âs pr√†cticament impossible no escoltar-lo. Les paraules esdr√∫ixoles s√≥n divertides. L'√®tica i l'√©tica s√≥n coses diferents. La br√∫ixola i l'√†ngel s√≥n paraules esdr√∫ixoles. √âs fant√†stic i pr√†ctic. La m√∫sica i la pr√†ctica s√≥n importants. La fru√Øci√≥ √©s una paraula plana, no esdr√∫ixola. L'√®tica a muntanya √©s important.`;
        toast("ok", "Text d'exemple", "S'ha carregat un text de prova.");
      });

      el.clearTextBtn.addEventListener("click", () => {
        el.inputText.value = "";
        toast("ok", "Text netejat", "El camp de text √©s buit.");
      });

      // Extract
      el.extractButton.addEventListener("click", extractSentences);

      // Init
      updateSearchTypeUI();
      updateNegationUI();
      updateAdjacentUI();
      setTimeout(extractSentences, 450);
    });
  </script>
</body>
</html>
